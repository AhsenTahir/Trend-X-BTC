"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/http_ece@1.2.0";
exports.ids = ["vendor-chunks/http_ece@1.2.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/http_ece@1.2.0/node_modules/http_ece/ece.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/http_ece@1.2.0/node_modules/http_ece/ece.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*\n * Encrypted content coding\n *\n * === Note about versions ===\n *\n * This code supports multiple versions of the draft.  This is selected using\n * the |version| parameter.\n *\n * aes128gcm: The most recent version, the salt, record size and key identifier\n *    are included in a header that is part of the encrypted content coding.\n *\n * aesgcm: The version that is widely deployed with WebPush (as of 2016-11).\n *    This version is selected by default, unless you specify a |padSize| of 1.\n */\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar AES_GCM = 'aes-128-gcm';\nvar PAD_SIZE = { 'aes128gcm': 1, 'aesgcm': 2 };\nvar TAG_LENGTH = 16;\nvar KEY_LENGTH = 16;\nvar NONCE_LENGTH = 12;\nvar SHA_256_LENGTH = 32;\nvar MODE_ENCRYPT = 'encrypt';\nvar MODE_DECRYPT = 'decrypt';\n\nvar keylog;\nif (process.env.ECE_KEYLOG === '1') {\n  keylog = function(m, k) {\n    console.warn(m + ' [' + k.length + ']: ' + k.toString('base64url'));\n    return k;\n  };\n} else {\n  keylog = function(m, k) { return k; };\n}\n\n/* Optionally base64 decode something. */\nfunction decode(b) {\n  if (typeof b === 'string') {\n    return Buffer.from(b, 'base64url');\n  }\n  return b;\n}\n\nfunction HMAC_hash(key, input) {\n  var hmac = crypto.createHmac('sha256', key);\n  hmac.update(input);\n  return hmac.digest();\n}\n\n/* HKDF as defined in RFC5869, using SHA-256 */\nfunction HKDF_extract(salt, ikm) {\n  keylog('salt', salt);\n  keylog('ikm', ikm);\n  return keylog('extract', HMAC_hash(salt, ikm));\n}\n\nfunction HKDF_expand(prk, info, l) {\n  keylog('prk', prk);\n  keylog('info', info);\n  var output = Buffer.alloc(0);\n  var T = Buffer.alloc(0);\n  info = Buffer.from(info, 'ascii');\n  var counter = 0;\n  var cbuf = Buffer.alloc(1);\n  while (output.length < l) {\n    cbuf.writeUIntBE(++counter, 0, 1);\n    T = HMAC_hash(prk, Buffer.concat([T, info, cbuf]));\n    output = Buffer.concat([output, T]);\n  }\n\n  return keylog('expand', output.slice(0, l));\n}\n\nfunction HKDF(salt, ikm, info, len) {\n  return HKDF_expand(HKDF_extract(salt, ikm), info, len);\n}\n\nfunction info(base, context) {\n  var result = Buffer.concat([\n    Buffer.from('Content-Encoding: ' + base + '\\0', 'ascii'),\n    context\n  ]);\n  keylog('info ' + base, result);\n  return result;\n}\n\nfunction lengthPrefix(buffer) {\n  var b = Buffer.concat([Buffer.alloc(2), buffer]);\n  b.writeUIntBE(buffer.length, 0, 2);\n  return b;\n}\n\nfunction extractDH(header, mode) {\n  var key = header.privateKey;\n  var senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = key.getPublicKey();\n    receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    senderPubKey = header.dh;\n    receiverPubKey = key.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT +\n                    ' and ' + MODE_DECRYPT + ' supported');\n  }\n  return {\n    secret: key.computeSecret(header.dh),\n    context: Buffer.concat([\n      Buffer.from(header.keylabel, 'ascii'),\n      Buffer.from([0]),\n      lengthPrefix(receiverPubKey), // user agent\n      lengthPrefix(senderPubKey)    // application server\n    ])\n  };\n}\n\nfunction extractSecretAndContext(header, mode) {\n  var result = { secret: null, context: Buffer.alloc(0) };\n  if (header.key) {\n    result.secret = header.key;\n    if (result.secret.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n  } else if (header.dh) { // receiver/decrypt\n    result = extractDH(header, mode);\n  } else if (typeof header.keyid !== undefined) {\n    result.secret = header.keymap[header.keyid];\n  }\n  if (!result.secret) {\n    throw new Error('Unable to determine key');\n  }\n  keylog('secret', result.secret);\n  keylog('context', result.context);\n  if (header.authSecret) {\n    result.secret = HKDF(header.authSecret, result.secret,\n                         info('auth', Buffer.alloc(0)), SHA_256_LENGTH);\n    keylog('authsecret', result.secret);\n  }\n  return result;\n}\n\nfunction webpushSecret(header, mode) {\n  if (!header.authSecret) {\n    throw new Error('No authentication secret for webpush');\n  }\n  keylog('authsecret', header.authSecret);\n\n  var remotePubKey, senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = header.privateKey.getPublicKey();\n    remotePubKey = receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    remotePubKey = senderPubKey = header.keyid;\n    receiverPubKey = header.privateKey.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT +\n                    ' and ' + MODE_DECRYPT + ' supported');\n  }\n  keylog('remote pubkey', remotePubKey);\n  keylog('sender pubkey', senderPubKey);\n  keylog('receiver pubkey', receiverPubKey);\n  return keylog('secret dh',\n                HKDF(header.authSecret,\n                     header.privateKey.computeSecret(remotePubKey),\n                     Buffer.concat([\n                       Buffer.from('WebPush: info\\0'),\n                       receiverPubKey,\n                       senderPubKey\n                     ]),\n                     SHA_256_LENGTH));\n}\n\nfunction extractSecret(header, mode, keyLookupCallback) {\n  if (keyLookupCallback) {\n    if (!isFunction(keyLookupCallback)) {\n      throw new Error('Callback is not a function')\n    }\n  }\n\n  if (header.key) {\n    if (header.key.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n    return keylog('secret key', header.key);\n  }\n\n  if (!header.privateKey) {\n    // Lookup based on keyid\n    if (!keyLookupCallback) {\n      var key = header.keymap && header.keymap[header.keyid];\n    } else {\n      var key = keyLookupCallback(header.keyid)\n    }\n    if (!key) {\n      throw new Error('No saved key (keyid: \"' + header.keyid + '\")');\n    }\n    return key;\n  }\n\n  return webpushSecret(header, mode);\n}\n\nfunction deriveKeyAndNonce(header, mode, lookupKeyCallback) {\n  if (!header.salt) {\n    throw new Error('must include a salt parameter for ' + header.version);\n  }\n  var keyInfo;\n  var nonceInfo;\n  var secret;\n  if (header.version === 'aesgcm') {\n    // old\n    var s = extractSecretAndContext(header, mode, lookupKeyCallback);\n    keyInfo = info('aesgcm', s.context);\n    nonceInfo = info('nonce', s.context);\n    secret = s.secret;\n  } else if (header.version === 'aes128gcm') {\n    // latest\n    keyInfo = Buffer.from('Content-Encoding: aes128gcm\\0');\n    nonceInfo = Buffer.from('Content-Encoding: nonce\\0');\n    secret = extractSecret(header, mode, lookupKeyCallback);\n  } else {\n    throw new Error('Unable to set context for mode ' + header.version);\n  }\n  var prk = HKDF_extract(header.salt, secret);\n  var result = {\n    key: HKDF_expand(prk, keyInfo, KEY_LENGTH),\n    nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)\n  };\n  keylog('key', result.key);\n  keylog('nonce base', result.nonce);\n  return result;\n}\n\n/* Parse command-line arguments. */\nfunction parseParams(params) {\n  var header = {};\n\n  header.version = params.version || 'aes128gcm';\n  header.rs = parseInt(params.rs, 10);\n  if (isNaN(header.rs)) {\n    header.rs = 4096;\n  }\n  var overhead = PAD_SIZE[header.version];\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  if (header.rs <= overhead) {\n    throw new Error('The rs parameter has to be greater than ' + overhead);\n  }\n\n  if (params.salt) {\n    header.salt = decode(params.salt);\n    if (header.salt.length !== KEY_LENGTH) {\n      throw new Error('The salt parameter must be ' + KEY_LENGTH + ' bytes');\n    }\n  }\n  header.keyid = params.keyid;\n  if (params.key) {\n    header.key = decode(params.key);\n  } else {\n    header.privateKey = params.privateKey;\n    if (!header.privateKey) {\n      header.keymap = params.keymap;\n    }\n    if (header.version !== 'aes128gcm') {\n      header.keylabel = params.keylabel || 'P-256';\n    }\n    if (params.dh) {\n      header.dh = decode(params.dh);\n    }\n  }\n  if (params.authSecret) {\n    header.authSecret = decode(params.authSecret);\n  }\n  return header;\n}\n\nfunction generateNonce(base, counter) {\n  var nonce = Buffer.from(base);\n  var m = nonce.readUIntBE(nonce.length - 6, 6);\n  var x = ((m ^ counter) & 0xffffff) +\n      ((((m / 0x1000000) ^ (counter / 0x1000000)) & 0xffffff) * 0x1000000);\n  nonce.writeUIntBE(x, nonce.length - 6, 6);\n  keylog('nonce' + counter, nonce);\n  return nonce;\n}\n\n/* Used when decrypting aes128gcm to populate the header values. Modifies the\n * header values in place and returns the size of the header. */\nfunction readHeader(buffer, header) {\n  var idsz = buffer.readUIntBE(20, 1);\n  header.salt = buffer.slice(0, KEY_LENGTH);\n  header.rs = buffer.readUIntBE(KEY_LENGTH, 4);\n  header.keyid = buffer.slice(21, 21 + idsz);\n  return 21 + idsz;\n}\n\nfunction unpadLegacy(data, version) {\n  var padSize = PAD_SIZE[version];\n  var pad = data.readUIntBE(0, padSize);\n  if (pad + padSize > data.length) {\n    throw new Error('padding exceeds block size');\n  }\n  keylog('padding', data.slice(0, padSize + pad));\n  var padCheck = Buffer.alloc(pad);\n  padCheck.fill(0);\n  if (padCheck.compare(data.slice(padSize, padSize + pad)) !== 0) {\n    throw new Error('invalid padding');\n  }\n  return data.slice(padSize + pad);\n}\n\nfunction unpad(data, last) {\n  var i = data.length - 1;\n  while(i >= 0) {\n    if (data[i]) {\n      if (last) {\n        if (data[i] !== 2) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      } else {\n        if (data[i] !== 1) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      }\n      return data.slice(0, i);\n    }\n    --i;\n  }\n  throw new Error('all zero plaintext');\n}\n\nfunction decryptRecord(key, counter, buffer, header, last) {\n  keylog('decrypt', buffer);\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createDecipheriv(AES_GCM, key.key, nonce);\n  gcm.setAuthTag(buffer.slice(buffer.length - TAG_LENGTH));\n  var data = gcm.update(buffer.slice(0, buffer.length - TAG_LENGTH));\n  data = Buffer.concat([data, gcm.final()]);\n  keylog('decrypted', data);\n  if (header.version !== 'aes128gcm') {\n    return unpadLegacy(data, header.version);\n  }\n  return unpad(data, last);\n}\n\n/**\n * Decrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.  Binary values are base64url encoded.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * If the version is aes128gcm, the keyid is extracted from the header and used\n * as the ECDH public key of the sender.  For version aesgcm ,\n * |params.dh| needs to be provided with the public key of the sender.\n *\n * The |params.privateKey| includes the private key of the receiver.\n */\nfunction decrypt(buffer, params, keyLookupCallback) {\n  var header = parseParams(params);\n  if (header.version === 'aes128gcm') {\n    var headerLength = readHeader(buffer, header);\n    buffer = buffer.slice(headerLength);\n  }\n  var key = deriveKeyAndNonce(header, MODE_DECRYPT, keyLookupCallback);\n  var start = 0;\n  var result = Buffer.alloc(0);\n\n  var chunkSize = header.rs;\n  if (header.version !== 'aes128gcm') {\n    chunkSize += TAG_LENGTH;\n  }\n\n  for (var i = 0; start < buffer.length; ++i) {\n    var end = start + chunkSize;\n    if (header.version !== 'aes128gcm' && end === buffer.length) {\n      throw new Error('Truncated payload');\n    }\n    end = Math.min(end, buffer.length);\n    if (end - start <= TAG_LENGTH) {\n      throw new Error('Invalid block: too small at ' + i);\n    }\n    var block = decryptRecord(key, i, buffer.slice(start, end),\n                              header, end >= buffer.length);\n    result = Buffer.concat([result, block]);\n    start = end;\n  }\n  return result;\n}\n\nfunction encryptRecord(key, counter, buffer, pad, header, last) {\n  keylog('encrypt', buffer);\n  pad = pad || 0;\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createCipheriv(AES_GCM, key.key, nonce);\n\n  var ciphertext = [];\n  var padSize = PAD_SIZE[header.version];\n  var padding = Buffer.alloc(pad + padSize);\n  padding.fill(0);\n\n  if (header.version !== 'aes128gcm') {\n    padding.writeUIntBE(pad, 0, padSize);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n    ciphertext.push(gcm.update(buffer));\n\n    if (!last && padding.length + buffer.length < header.rs) {\n      throw new Error('Unable to pad to record size');\n    }\n  } else {\n    ciphertext.push(gcm.update(buffer));\n    padding.writeUIntBE(last ? 2 : 1, 0, 1);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n  }\n\n  gcm.final();\n  var tag = gcm.getAuthTag();\n  if (tag.length !== TAG_LENGTH) {\n    throw new Error('invalid tag generated');\n  }\n  ciphertext.push(tag);\n  return keylog('encrypted', Buffer.concat(ciphertext));\n}\n\nfunction writeHeader(header) {\n  var ints = Buffer.alloc(5);\n  var keyid = Buffer.from(header.keyid || []);\n  if (keyid.length > 255) {\n    throw new Error('keyid is too large');\n  }\n  ints.writeUIntBE(header.rs, 0, 4);\n  ints.writeUIntBE(keyid.length, 4, 1);\n  return Buffer.concat([header.salt, ints, keyid]);\n}\n\n/**\n * Encrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter two might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * For Diffie-Hellman (WebPush), |params.dh| includes the public key of the\n * receiver.  |params.privateKey| is used to establish a shared secret.  Key\n * pairs can be created using |crypto.createECDH()|.\n */\nfunction encrypt(buffer, params, keyLookupCallback) {  \n  if (!Buffer.isBuffer(buffer)) {\n    throw new Error('buffer argument must be a Buffer');\n  }\n  var header = parseParams(params);\n  if (!header.salt) {\n    header.salt = crypto.randomBytes(KEY_LENGTH);\n  }\n\n  var result;\n  if (header.version === 'aes128gcm') {\n    // Save the DH public key in the header unless keyid is set.\n    if (header.privateKey && !header.keyid) {\n      header.keyid = header.privateKey.getPublicKey();\n    }\n    result = writeHeader(header);\n  } else {\n    // No header on other versions\n    result = Buffer.alloc(0);\n  }\n\n  var key = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);\n  var start = 0;\n  var padSize = PAD_SIZE[header.version];\n  var overhead = padSize;\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  var pad = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);\n\n  var counter = 0;\n  var last = false;\n  while (!last) {\n    // Pad so that at least one data byte is in a block.\n    var recordPad = Math.min(header.rs - overhead - 1, pad);\n    if (header.version !== 'aes128gcm') {\n      recordPad = Math.min((1 << (padSize * 8)) - 1, recordPad);\n    }\n    if (pad > 0 && recordPad === 0) {\n      ++recordPad; // Deal with perverse case of rs=overhead+1 with padding.\n    }\n    pad -= recordPad;\n\n    var end = start + header.rs - overhead - recordPad;\n    if (header.version !== 'aes128gcm') {\n      // The > here ensures that we write out a padding-only block at the end\n      // of a buffer.\n      last = end > buffer.length;\n    } else {\n      last = end >= buffer.length;\n    }\n    last = last && pad <= 0;\n    var block = encryptRecord(key, counter, buffer.slice(start, end),\n                              recordPad, header, last);\n    result = Buffer.concat([result, block]);\n\n    start = end;\n    ++counter;\n  }\n  return result;\n}\n\n\nfunction isFunction(object) {\n  return typeof(object) === 'function';\n }\n\nmodule.exports = {\n  decrypt: decrypt,\n  encrypt: encrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vaHR0cF9lY2VAMS4yLjAvbm9kZV9tb2R1bGVzL2h0dHBfZWNlL2VjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHNCQUFROztBQUU3QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0JBQXNCO0FBQzFCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0anMvLi9ub2RlX21vZHVsZXMvLnBucG0vaHR0cF9lY2VAMS4yLjAvbm9kZV9tb2R1bGVzL2h0dHBfZWNlL2VjZS5qcz9lODZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qXG4gKiBFbmNyeXB0ZWQgY29udGVudCBjb2RpbmdcbiAqXG4gKiA9PT0gTm90ZSBhYm91dCB2ZXJzaW9ucyA9PT1cbiAqXG4gKiBUaGlzIGNvZGUgc3VwcG9ydHMgbXVsdGlwbGUgdmVyc2lvbnMgb2YgdGhlIGRyYWZ0LiAgVGhpcyBpcyBzZWxlY3RlZCB1c2luZ1xuICogdGhlIHx2ZXJzaW9ufCBwYXJhbWV0ZXIuXG4gKlxuICogYWVzMTI4Z2NtOiBUaGUgbW9zdCByZWNlbnQgdmVyc2lvbiwgdGhlIHNhbHQsIHJlY29yZCBzaXplIGFuZCBrZXkgaWRlbnRpZmllclxuICogICAgYXJlIGluY2x1ZGVkIGluIGEgaGVhZGVyIHRoYXQgaXMgcGFydCBvZiB0aGUgZW5jcnlwdGVkIGNvbnRlbnQgY29kaW5nLlxuICpcbiAqIGFlc2djbTogVGhlIHZlcnNpb24gdGhhdCBpcyB3aWRlbHkgZGVwbG95ZWQgd2l0aCBXZWJQdXNoIChhcyBvZiAyMDE2LTExKS5cbiAqICAgIFRoaXMgdmVyc2lvbiBpcyBzZWxlY3RlZCBieSBkZWZhdWx0LCB1bmxlc3MgeW91IHNwZWNpZnkgYSB8cGFkU2l6ZXwgb2YgMS5cbiAqL1xuXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbnZhciBBRVNfR0NNID0gJ2Flcy0xMjgtZ2NtJztcbnZhciBQQURfU0laRSA9IHsgJ2FlczEyOGdjbSc6IDEsICdhZXNnY20nOiAyIH07XG52YXIgVEFHX0xFTkdUSCA9IDE2O1xudmFyIEtFWV9MRU5HVEggPSAxNjtcbnZhciBOT05DRV9MRU5HVEggPSAxMjtcbnZhciBTSEFfMjU2X0xFTkdUSCA9IDMyO1xudmFyIE1PREVfRU5DUllQVCA9ICdlbmNyeXB0JztcbnZhciBNT0RFX0RFQ1JZUFQgPSAnZGVjcnlwdCc7XG5cbnZhciBrZXlsb2c7XG5pZiAocHJvY2Vzcy5lbnYuRUNFX0tFWUxPRyA9PT0gJzEnKSB7XG4gIGtleWxvZyA9IGZ1bmN0aW9uKG0sIGspIHtcbiAgICBjb25zb2xlLndhcm4obSArICcgWycgKyBrLmxlbmd0aCArICddOiAnICsgay50b1N0cmluZygnYmFzZTY0dXJsJykpO1xuICAgIHJldHVybiBrO1xuICB9O1xufSBlbHNlIHtcbiAga2V5bG9nID0gZnVuY3Rpb24obSwgaykgeyByZXR1cm4gazsgfTtcbn1cblxuLyogT3B0aW9uYWxseSBiYXNlNjQgZGVjb2RlIHNvbWV0aGluZy4gKi9cbmZ1bmN0aW9uIGRlY29kZShiKSB7XG4gIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYiwgJ2Jhc2U2NHVybCcpO1xuICB9XG4gIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBITUFDX2hhc2goa2V5LCBpbnB1dCkge1xuICB2YXIgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKCdzaGEyNTYnLCBrZXkpO1xuICBobWFjLnVwZGF0ZShpbnB1dCk7XG4gIHJldHVybiBobWFjLmRpZ2VzdCgpO1xufVxuXG4vKiBIS0RGIGFzIGRlZmluZWQgaW4gUkZDNTg2OSwgdXNpbmcgU0hBLTI1NiAqL1xuZnVuY3Rpb24gSEtERl9leHRyYWN0KHNhbHQsIGlrbSkge1xuICBrZXlsb2coJ3NhbHQnLCBzYWx0KTtcbiAga2V5bG9nKCdpa20nLCBpa20pO1xuICByZXR1cm4ga2V5bG9nKCdleHRyYWN0JywgSE1BQ19oYXNoKHNhbHQsIGlrbSkpO1xufVxuXG5mdW5jdGlvbiBIS0RGX2V4cGFuZChwcmssIGluZm8sIGwpIHtcbiAga2V5bG9nKCdwcmsnLCBwcmspO1xuICBrZXlsb2coJ2luZm8nLCBpbmZvKTtcbiAgdmFyIG91dHB1dCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgdmFyIFQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIGluZm8gPSBCdWZmZXIuZnJvbShpbmZvLCAnYXNjaWknKTtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuICB2YXIgY2J1ZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgd2hpbGUgKG91dHB1dC5sZW5ndGggPCBsKSB7XG4gICAgY2J1Zi53cml0ZVVJbnRCRSgrK2NvdW50ZXIsIDAsIDEpO1xuICAgIFQgPSBITUFDX2hhc2gocHJrLCBCdWZmZXIuY29uY2F0KFtULCBpbmZvLCBjYnVmXSkpO1xuICAgIG91dHB1dCA9IEJ1ZmZlci5jb25jYXQoW291dHB1dCwgVF0pO1xuICB9XG5cbiAgcmV0dXJuIGtleWxvZygnZXhwYW5kJywgb3V0cHV0LnNsaWNlKDAsIGwpKTtcbn1cblxuZnVuY3Rpb24gSEtERihzYWx0LCBpa20sIGluZm8sIGxlbikge1xuICByZXR1cm4gSEtERl9leHBhbmQoSEtERl9leHRyYWN0KHNhbHQsIGlrbSksIGluZm8sIGxlbik7XG59XG5cbmZ1bmN0aW9uIGluZm8oYmFzZSwgY29udGV4dCkge1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmNvbmNhdChbXG4gICAgQnVmZmVyLmZyb20oJ0NvbnRlbnQtRW5jb2Rpbmc6ICcgKyBiYXNlICsgJ1xcMCcsICdhc2NpaScpLFxuICAgIGNvbnRleHRcbiAgXSk7XG4gIGtleWxvZygnaW5mbyAnICsgYmFzZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoUHJlZml4KGJ1ZmZlcikge1xuICB2YXIgYiA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5hbGxvYygyKSwgYnVmZmVyXSk7XG4gIGIud3JpdGVVSW50QkUoYnVmZmVyLmxlbmd0aCwgMCwgMik7XG4gIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0REgoaGVhZGVyLCBtb2RlKSB7XG4gIHZhciBrZXkgPSBoZWFkZXIucHJpdmF0ZUtleTtcbiAgdmFyIHNlbmRlclB1YktleSwgcmVjZWl2ZXJQdWJLZXk7XG4gIGlmIChtb2RlID09PSBNT0RFX0VOQ1JZUFQpIHtcbiAgICBzZW5kZXJQdWJLZXkgPSBrZXkuZ2V0UHVibGljS2V5KCk7XG4gICAgcmVjZWl2ZXJQdWJLZXkgPSBoZWFkZXIuZGg7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gTU9ERV9ERUNSWVBUKSB7XG4gICAgc2VuZGVyUHViS2V5ID0gaGVhZGVyLmRoO1xuICAgIHJlY2VpdmVyUHViS2V5ID0ga2V5LmdldFB1YmxpY0tleSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlIG9ubHkgJyArIE1PREVfRU5DUllQVCArXG4gICAgICAgICAgICAgICAgICAgICcgYW5kICcgKyBNT0RFX0RFQ1JZUFQgKyAnIHN1cHBvcnRlZCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2VjcmV0OiBrZXkuY29tcHV0ZVNlY3JldChoZWFkZXIuZGgpLFxuICAgIGNvbnRleHQ6IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgQnVmZmVyLmZyb20oaGVhZGVyLmtleWxhYmVsLCAnYXNjaWknKSxcbiAgICAgIEJ1ZmZlci5mcm9tKFswXSksXG4gICAgICBsZW5ndGhQcmVmaXgocmVjZWl2ZXJQdWJLZXkpLCAvLyB1c2VyIGFnZW50XG4gICAgICBsZW5ndGhQcmVmaXgoc2VuZGVyUHViS2V5KSAgICAvLyBhcHBsaWNhdGlvbiBzZXJ2ZXJcbiAgICBdKVxuICB9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0U2VjcmV0QW5kQ29udGV4dChoZWFkZXIsIG1vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IHsgc2VjcmV0OiBudWxsLCBjb250ZXh0OiBCdWZmZXIuYWxsb2MoMCkgfTtcbiAgaWYgKGhlYWRlci5rZXkpIHtcbiAgICByZXN1bHQuc2VjcmV0ID0gaGVhZGVyLmtleTtcbiAgICBpZiAocmVzdWx0LnNlY3JldC5sZW5ndGggIT09IEtFWV9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gZXhwbGljaXQga2V5IG11c3QgYmUgJyArIEtFWV9MRU5HVEggKyAnIGJ5dGVzJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlci5kaCkgeyAvLyByZWNlaXZlci9kZWNyeXB0XG4gICAgcmVzdWx0ID0gZXh0cmFjdERIKGhlYWRlciwgbW9kZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGhlYWRlci5rZXlpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmVzdWx0LnNlY3JldCA9IGhlYWRlci5rZXltYXBbaGVhZGVyLmtleWlkXTtcbiAgfVxuICBpZiAoIXJlc3VsdC5zZWNyZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZXRlcm1pbmUga2V5Jyk7XG4gIH1cbiAga2V5bG9nKCdzZWNyZXQnLCByZXN1bHQuc2VjcmV0KTtcbiAga2V5bG9nKCdjb250ZXh0JywgcmVzdWx0LmNvbnRleHQpO1xuICBpZiAoaGVhZGVyLmF1dGhTZWNyZXQpIHtcbiAgICByZXN1bHQuc2VjcmV0ID0gSEtERihoZWFkZXIuYXV0aFNlY3JldCwgcmVzdWx0LnNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvKCdhdXRoJywgQnVmZmVyLmFsbG9jKDApKSwgU0hBXzI1Nl9MRU5HVEgpO1xuICAgIGtleWxvZygnYXV0aHNlY3JldCcsIHJlc3VsdC5zZWNyZXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdlYnB1c2hTZWNyZXQoaGVhZGVyLCBtb2RlKSB7XG4gIGlmICghaGVhZGVyLmF1dGhTZWNyZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGF1dGhlbnRpY2F0aW9uIHNlY3JldCBmb3Igd2VicHVzaCcpO1xuICB9XG4gIGtleWxvZygnYXV0aHNlY3JldCcsIGhlYWRlci5hdXRoU2VjcmV0KTtcblxuICB2YXIgcmVtb3RlUHViS2V5LCBzZW5kZXJQdWJLZXksIHJlY2VpdmVyUHViS2V5O1xuICBpZiAobW9kZSA9PT0gTU9ERV9FTkNSWVBUKSB7XG4gICAgc2VuZGVyUHViS2V5ID0gaGVhZGVyLnByaXZhdGVLZXkuZ2V0UHVibGljS2V5KCk7XG4gICAgcmVtb3RlUHViS2V5ID0gcmVjZWl2ZXJQdWJLZXkgPSBoZWFkZXIuZGg7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gTU9ERV9ERUNSWVBUKSB7XG4gICAgcmVtb3RlUHViS2V5ID0gc2VuZGVyUHViS2V5ID0gaGVhZGVyLmtleWlkO1xuICAgIHJlY2VpdmVyUHViS2V5ID0gaGVhZGVyLnByaXZhdGVLZXkuZ2V0UHVibGljS2V5KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGUgb25seSAnICsgTU9ERV9FTkNSWVBUICtcbiAgICAgICAgICAgICAgICAgICAgJyBhbmQgJyArIE1PREVfREVDUllQVCArICcgc3VwcG9ydGVkJyk7XG4gIH1cbiAga2V5bG9nKCdyZW1vdGUgcHVia2V5JywgcmVtb3RlUHViS2V5KTtcbiAga2V5bG9nKCdzZW5kZXIgcHVia2V5Jywgc2VuZGVyUHViS2V5KTtcbiAga2V5bG9nKCdyZWNlaXZlciBwdWJrZXknLCByZWNlaXZlclB1YktleSk7XG4gIHJldHVybiBrZXlsb2coJ3NlY3JldCBkaCcsXG4gICAgICAgICAgICAgICAgSEtERihoZWFkZXIuYXV0aFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgIGhlYWRlci5wcml2YXRlS2V5LmNvbXB1dGVTZWNyZXQocmVtb3RlUHViS2V5KSxcbiAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbSgnV2ViUHVzaDogaW5mb1xcMCcpLFxuICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlclB1YktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyUHViS2V5XG4gICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgIFNIQV8yNTZfTEVOR1RIKSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RTZWNyZXQoaGVhZGVyLCBtb2RlLCBrZXlMb29rdXBDYWxsYmFjaykge1xuICBpZiAoa2V5TG9va3VwQ2FsbGJhY2spIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oa2V5TG9va3VwQ2FsbGJhY2spKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uJylcbiAgICB9XG4gIH1cblxuICBpZiAoaGVhZGVyLmtleSkge1xuICAgIGlmIChoZWFkZXIua2V5Lmxlbmd0aCAhPT0gS0VZX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBleHBsaWNpdCBrZXkgbXVzdCBiZSAnICsgS0VZX0xFTkdUSCArICcgYnl0ZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleWxvZygnc2VjcmV0IGtleScsIGhlYWRlci5rZXkpO1xuICB9XG5cbiAgaWYgKCFoZWFkZXIucHJpdmF0ZUtleSkge1xuICAgIC8vIExvb2t1cCBiYXNlZCBvbiBrZXlpZFxuICAgIGlmICgha2V5TG9va3VwQ2FsbGJhY2spIHtcbiAgICAgIHZhciBrZXkgPSBoZWFkZXIua2V5bWFwICYmIGhlYWRlci5rZXltYXBbaGVhZGVyLmtleWlkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleSA9IGtleUxvb2t1cENhbGxiYWNrKGhlYWRlci5rZXlpZClcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2F2ZWQga2V5IChrZXlpZDogXCInICsgaGVhZGVyLmtleWlkICsgJ1wiKScpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgcmV0dXJuIHdlYnB1c2hTZWNyZXQoaGVhZGVyLCBtb2RlKTtcbn1cblxuZnVuY3Rpb24gZGVyaXZlS2V5QW5kTm9uY2UoaGVhZGVyLCBtb2RlLCBsb29rdXBLZXlDYWxsYmFjaykge1xuICBpZiAoIWhlYWRlci5zYWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGluY2x1ZGUgYSBzYWx0IHBhcmFtZXRlciBmb3IgJyArIGhlYWRlci52ZXJzaW9uKTtcbiAgfVxuICB2YXIga2V5SW5mbztcbiAgdmFyIG5vbmNlSW5mbztcbiAgdmFyIHNlY3JldDtcbiAgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzZ2NtJykge1xuICAgIC8vIG9sZFxuICAgIHZhciBzID0gZXh0cmFjdFNlY3JldEFuZENvbnRleHQoaGVhZGVyLCBtb2RlLCBsb29rdXBLZXlDYWxsYmFjayk7XG4gICAga2V5SW5mbyA9IGluZm8oJ2Flc2djbScsIHMuY29udGV4dCk7XG4gICAgbm9uY2VJbmZvID0gaW5mbygnbm9uY2UnLCBzLmNvbnRleHQpO1xuICAgIHNlY3JldCA9IHMuc2VjcmV0O1xuICB9IGVsc2UgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzMTI4Z2NtJykge1xuICAgIC8vIGxhdGVzdFxuICAgIGtleUluZm8gPSBCdWZmZXIuZnJvbSgnQ29udGVudC1FbmNvZGluZzogYWVzMTI4Z2NtXFwwJyk7XG4gICAgbm9uY2VJbmZvID0gQnVmZmVyLmZyb20oJ0NvbnRlbnQtRW5jb2Rpbmc6IG5vbmNlXFwwJyk7XG4gICAgc2VjcmV0ID0gZXh0cmFjdFNlY3JldChoZWFkZXIsIG1vZGUsIGxvb2t1cEtleUNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZXQgY29udGV4dCBmb3IgbW9kZSAnICsgaGVhZGVyLnZlcnNpb24pO1xuICB9XG4gIHZhciBwcmsgPSBIS0RGX2V4dHJhY3QoaGVhZGVyLnNhbHQsIHNlY3JldCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAga2V5OiBIS0RGX2V4cGFuZChwcmssIGtleUluZm8sIEtFWV9MRU5HVEgpLFxuICAgIG5vbmNlOiBIS0RGX2V4cGFuZChwcmssIG5vbmNlSW5mbywgTk9OQ0VfTEVOR1RIKVxuICB9O1xuICBrZXlsb2coJ2tleScsIHJlc3VsdC5rZXkpO1xuICBrZXlsb2coJ25vbmNlIGJhc2UnLCByZXN1bHQubm9uY2UpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiBQYXJzZSBjb21tYW5kLWxpbmUgYXJndW1lbnRzLiAqL1xuZnVuY3Rpb24gcGFyc2VQYXJhbXMocGFyYW1zKSB7XG4gIHZhciBoZWFkZXIgPSB7fTtcblxuICBoZWFkZXIudmVyc2lvbiA9IHBhcmFtcy52ZXJzaW9uIHx8ICdhZXMxMjhnY20nO1xuICBoZWFkZXIucnMgPSBwYXJzZUludChwYXJhbXMucnMsIDEwKTtcbiAgaWYgKGlzTmFOKGhlYWRlci5ycykpIHtcbiAgICBoZWFkZXIucnMgPSA0MDk2O1xuICB9XG4gIHZhciBvdmVyaGVhZCA9IFBBRF9TSVpFW2hlYWRlci52ZXJzaW9uXTtcbiAgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzMTI4Z2NtJykge1xuICAgIG92ZXJoZWFkICs9IFRBR19MRU5HVEg7XG4gIH1cbiAgaWYgKGhlYWRlci5ycyA8PSBvdmVyaGVhZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJzIHBhcmFtZXRlciBoYXMgdG8gYmUgZ3JlYXRlciB0aGFuICcgKyBvdmVyaGVhZCk7XG4gIH1cblxuICBpZiAocGFyYW1zLnNhbHQpIHtcbiAgICBoZWFkZXIuc2FsdCA9IGRlY29kZShwYXJhbXMuc2FsdCk7XG4gICAgaWYgKGhlYWRlci5zYWx0Lmxlbmd0aCAhPT0gS0VZX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2FsdCBwYXJhbWV0ZXIgbXVzdCBiZSAnICsgS0VZX0xFTkdUSCArICcgYnl0ZXMnKTtcbiAgICB9XG4gIH1cbiAgaGVhZGVyLmtleWlkID0gcGFyYW1zLmtleWlkO1xuICBpZiAocGFyYW1zLmtleSkge1xuICAgIGhlYWRlci5rZXkgPSBkZWNvZGUocGFyYW1zLmtleSk7XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyLnByaXZhdGVLZXkgPSBwYXJhbXMucHJpdmF0ZUtleTtcbiAgICBpZiAoIWhlYWRlci5wcml2YXRlS2V5KSB7XG4gICAgICBoZWFkZXIua2V5bWFwID0gcGFyYW1zLmtleW1hcDtcbiAgICB9XG4gICAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJykge1xuICAgICAgaGVhZGVyLmtleWxhYmVsID0gcGFyYW1zLmtleWxhYmVsIHx8ICdQLTI1Nic7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuZGgpIHtcbiAgICAgIGhlYWRlci5kaCA9IGRlY29kZShwYXJhbXMuZGgpO1xuICAgIH1cbiAgfVxuICBpZiAocGFyYW1zLmF1dGhTZWNyZXQpIHtcbiAgICBoZWFkZXIuYXV0aFNlY3JldCA9IGRlY29kZShwYXJhbXMuYXV0aFNlY3JldCk7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcjtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOb25jZShiYXNlLCBjb3VudGVyKSB7XG4gIHZhciBub25jZSA9IEJ1ZmZlci5mcm9tKGJhc2UpO1xuICB2YXIgbSA9IG5vbmNlLnJlYWRVSW50QkUobm9uY2UubGVuZ3RoIC0gNiwgNik7XG4gIHZhciB4ID0gKChtIF4gY291bnRlcikgJiAweGZmZmZmZikgK1xuICAgICAgKCgoKG0gLyAweDEwMDAwMDApIF4gKGNvdW50ZXIgLyAweDEwMDAwMDApKSAmIDB4ZmZmZmZmKSAqIDB4MTAwMDAwMCk7XG4gIG5vbmNlLndyaXRlVUludEJFKHgsIG5vbmNlLmxlbmd0aCAtIDYsIDYpO1xuICBrZXlsb2coJ25vbmNlJyArIGNvdW50ZXIsIG5vbmNlKTtcbiAgcmV0dXJuIG5vbmNlO1xufVxuXG4vKiBVc2VkIHdoZW4gZGVjcnlwdGluZyBhZXMxMjhnY20gdG8gcG9wdWxhdGUgdGhlIGhlYWRlciB2YWx1ZXMuIE1vZGlmaWVzIHRoZVxuICogaGVhZGVyIHZhbHVlcyBpbiBwbGFjZSBhbmQgcmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgaGVhZGVyLiAqL1xuZnVuY3Rpb24gcmVhZEhlYWRlcihidWZmZXIsIGhlYWRlcikge1xuICB2YXIgaWRzeiA9IGJ1ZmZlci5yZWFkVUludEJFKDIwLCAxKTtcbiAgaGVhZGVyLnNhbHQgPSBidWZmZXIuc2xpY2UoMCwgS0VZX0xFTkdUSCk7XG4gIGhlYWRlci5ycyA9IGJ1ZmZlci5yZWFkVUludEJFKEtFWV9MRU5HVEgsIDQpO1xuICBoZWFkZXIua2V5aWQgPSBidWZmZXIuc2xpY2UoMjEsIDIxICsgaWRzeik7XG4gIHJldHVybiAyMSArIGlkc3o7XG59XG5cbmZ1bmN0aW9uIHVucGFkTGVnYWN5KGRhdGEsIHZlcnNpb24pIHtcbiAgdmFyIHBhZFNpemUgPSBQQURfU0laRVt2ZXJzaW9uXTtcbiAgdmFyIHBhZCA9IGRhdGEucmVhZFVJbnRCRSgwLCBwYWRTaXplKTtcbiAgaWYgKHBhZCArIHBhZFNpemUgPiBkYXRhLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBleGNlZWRzIGJsb2NrIHNpemUnKTtcbiAgfVxuICBrZXlsb2coJ3BhZGRpbmcnLCBkYXRhLnNsaWNlKDAsIHBhZFNpemUgKyBwYWQpKTtcbiAgdmFyIHBhZENoZWNrID0gQnVmZmVyLmFsbG9jKHBhZCk7XG4gIHBhZENoZWNrLmZpbGwoMCk7XG4gIGlmIChwYWRDaGVjay5jb21wYXJlKGRhdGEuc2xpY2UocGFkU2l6ZSwgcGFkU2l6ZSArIHBhZCkpICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhZGRpbmcnKTtcbiAgfVxuICByZXR1cm4gZGF0YS5zbGljZShwYWRTaXplICsgcGFkKTtcbn1cblxuZnVuY3Rpb24gdW5wYWQoZGF0YSwgbGFzdCkge1xuICB2YXIgaSA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgd2hpbGUoaSA+PSAwKSB7XG4gICAgaWYgKGRhdGFbaV0pIHtcbiAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgIGlmIChkYXRhW2ldICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYXN0IHJlY29yZCBuZWVkcyB0byBzdGFydCBwYWRkaW5nIHdpdGggYSAyJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkYXRhW2ldICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYXN0IHJlY29yZCBuZWVkcyB0byBzdGFydCBwYWRkaW5nIHdpdGggYSAyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhLnNsaWNlKDAsIGkpO1xuICAgIH1cbiAgICAtLWk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdhbGwgemVybyBwbGFpbnRleHQnKTtcbn1cblxuZnVuY3Rpb24gZGVjcnlwdFJlY29yZChrZXksIGNvdW50ZXIsIGJ1ZmZlciwgaGVhZGVyLCBsYXN0KSB7XG4gIGtleWxvZygnZGVjcnlwdCcsIGJ1ZmZlcik7XG4gIHZhciBub25jZSA9IGdlbmVyYXRlTm9uY2Uoa2V5Lm5vbmNlLCBjb3VudGVyKTtcbiAgdmFyIGdjbSA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KEFFU19HQ00sIGtleS5rZXksIG5vbmNlKTtcbiAgZ2NtLnNldEF1dGhUYWcoYnVmZmVyLnNsaWNlKGJ1ZmZlci5sZW5ndGggLSBUQUdfTEVOR1RIKSk7XG4gIHZhciBkYXRhID0gZ2NtLnVwZGF0ZShidWZmZXIuc2xpY2UoMCwgYnVmZmVyLmxlbmd0aCAtIFRBR19MRU5HVEgpKTtcbiAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RhdGEsIGdjbS5maW5hbCgpXSk7XG4gIGtleWxvZygnZGVjcnlwdGVkJywgZGF0YSk7XG4gIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICByZXR1cm4gdW5wYWRMZWdhY3koZGF0YSwgaGVhZGVyLnZlcnNpb24pO1xuICB9XG4gIHJldHVybiB1bnBhZChkYXRhLCBsYXN0KTtcbn1cblxuLyoqXG4gKiBEZWNyeXB0IHNvbWUgYnl0ZXMuICBUaGlzIHVzZXMgdGhlIHBhcmFtZXRlcnMgdG8gZGV0ZXJtaW5lIHRoZSBrZXkgYW5kIGJsb2NrXG4gKiBzaXplLCB3aGljaCBhcmUgZGVzY3JpYmVkIGluIHRoZSBkcmFmdC4gIEJpbmFyeSB2YWx1ZXMgYXJlIGJhc2U2NHVybCBlbmNvZGVkLlxuICpcbiAqIHxwYXJhbXMudmVyc2lvbnwgY29udGFpbnMgdGhlIHZlcnNpb24gb2YgZW5jb2RpbmcgdG8gdXNlOiBhZXMxMjhnY20gaXMgdGhlIGxhdGVzdCxcbiAqIGJ1dCBhZXNnY20gaXMgYWxzbyBhY2NlcHRlZCAodGhvdWdoIHRoZSBsYXR0ZXIgbWlnaHRcbiAqIGRpc2FwcGVhciBpbiBhIGZ1dHVyZSByZWxlYXNlKS4gIElmIG9taXR0ZWQsIGFzc3VtZSBhZXMxMjhnY20uXG4gKlxuICogSWYgfHBhcmFtcy5rZXl8IGlzIHNwZWNpZmllZCwgdGhhdCB2YWx1ZSBpcyB1c2VkIGFzIHRoZSBrZXkuXG4gKlxuICogSWYgdGhlIHZlcnNpb24gaXMgYWVzMTI4Z2NtLCB0aGUga2V5aWQgaXMgZXh0cmFjdGVkIGZyb20gdGhlIGhlYWRlciBhbmQgdXNlZFxuICogYXMgdGhlIEVDREggcHVibGljIGtleSBvZiB0aGUgc2VuZGVyLiAgRm9yIHZlcnNpb24gYWVzZ2NtICxcbiAqIHxwYXJhbXMuZGh8IG5lZWRzIHRvIGJlIHByb3ZpZGVkIHdpdGggdGhlIHB1YmxpYyBrZXkgb2YgdGhlIHNlbmRlci5cbiAqXG4gKiBUaGUgfHBhcmFtcy5wcml2YXRlS2V5fCBpbmNsdWRlcyB0aGUgcHJpdmF0ZSBrZXkgb2YgdGhlIHJlY2VpdmVyLlxuICovXG5mdW5jdGlvbiBkZWNyeXB0KGJ1ZmZlciwgcGFyYW1zLCBrZXlMb29rdXBDYWxsYmFjaykge1xuICB2YXIgaGVhZGVyID0gcGFyc2VQYXJhbXMocGFyYW1zKTtcbiAgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzMTI4Z2NtJykge1xuICAgIHZhciBoZWFkZXJMZW5ndGggPSByZWFkSGVhZGVyKGJ1ZmZlciwgaGVhZGVyKTtcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoaGVhZGVyTGVuZ3RoKTtcbiAgfVxuICB2YXIga2V5ID0gZGVyaXZlS2V5QW5kTm9uY2UoaGVhZGVyLCBNT0RFX0RFQ1JZUFQsIGtleUxvb2t1cENhbGxiYWNrKTtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYygwKTtcblxuICB2YXIgY2h1bmtTaXplID0gaGVhZGVyLnJzO1xuICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nKSB7XG4gICAgY2h1bmtTaXplICs9IFRBR19MRU5HVEg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgc3RhcnQgPCBidWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZW5kID0gc3RhcnQgKyBjaHVua1NpemU7XG4gICAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJyAmJiBlbmQgPT09IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJ1bmNhdGVkIHBheWxvYWQnKTtcbiAgICB9XG4gICAgZW5kID0gTWF0aC5taW4oZW5kLCBidWZmZXIubGVuZ3RoKTtcbiAgICBpZiAoZW5kIC0gc3RhcnQgPD0gVEFHX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJsb2NrOiB0b28gc21hbGwgYXQgJyArIGkpO1xuICAgIH1cbiAgICB2YXIgYmxvY2sgPSBkZWNyeXB0UmVjb3JkKGtleSwgaSwgYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLCBlbmQgPj0gYnVmZmVyLmxlbmd0aCk7XG4gICAgcmVzdWx0ID0gQnVmZmVyLmNvbmNhdChbcmVzdWx0LCBibG9ja10pO1xuICAgIHN0YXJ0ID0gZW5kO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGVuY3J5cHRSZWNvcmQoa2V5LCBjb3VudGVyLCBidWZmZXIsIHBhZCwgaGVhZGVyLCBsYXN0KSB7XG4gIGtleWxvZygnZW5jcnlwdCcsIGJ1ZmZlcik7XG4gIHBhZCA9IHBhZCB8fCAwO1xuICB2YXIgbm9uY2UgPSBnZW5lcmF0ZU5vbmNlKGtleS5ub25jZSwgY291bnRlcik7XG4gIHZhciBnY20gPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoQUVTX0dDTSwga2V5LmtleSwgbm9uY2UpO1xuXG4gIHZhciBjaXBoZXJ0ZXh0ID0gW107XG4gIHZhciBwYWRTaXplID0gUEFEX1NJWkVbaGVhZGVyLnZlcnNpb25dO1xuICB2YXIgcGFkZGluZyA9IEJ1ZmZlci5hbGxvYyhwYWQgKyBwYWRTaXplKTtcbiAgcGFkZGluZy5maWxsKDApO1xuXG4gIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICBwYWRkaW5nLndyaXRlVUludEJFKHBhZCwgMCwgcGFkU2l6ZSk7XG4gICAga2V5bG9nKCdwYWRkaW5nJywgcGFkZGluZyk7XG4gICAgY2lwaGVydGV4dC5wdXNoKGdjbS51cGRhdGUocGFkZGluZykpO1xuICAgIGNpcGhlcnRleHQucHVzaChnY20udXBkYXRlKGJ1ZmZlcikpO1xuXG4gICAgaWYgKCFsYXN0ICYmIHBhZGRpbmcubGVuZ3RoICsgYnVmZmVyLmxlbmd0aCA8IGhlYWRlci5ycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFkIHRvIHJlY29yZCBzaXplJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNpcGhlcnRleHQucHVzaChnY20udXBkYXRlKGJ1ZmZlcikpO1xuICAgIHBhZGRpbmcud3JpdGVVSW50QkUobGFzdCA/IDIgOiAxLCAwLCAxKTtcbiAgICBrZXlsb2coJ3BhZGRpbmcnLCBwYWRkaW5nKTtcbiAgICBjaXBoZXJ0ZXh0LnB1c2goZ2NtLnVwZGF0ZShwYWRkaW5nKSk7XG4gIH1cblxuICBnY20uZmluYWwoKTtcbiAgdmFyIHRhZyA9IGdjbS5nZXRBdXRoVGFnKCk7XG4gIGlmICh0YWcubGVuZ3RoICE9PSBUQUdfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRhZyBnZW5lcmF0ZWQnKTtcbiAgfVxuICBjaXBoZXJ0ZXh0LnB1c2godGFnKTtcbiAgcmV0dXJuIGtleWxvZygnZW5jcnlwdGVkJywgQnVmZmVyLmNvbmNhdChjaXBoZXJ0ZXh0KSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlSGVhZGVyKGhlYWRlcikge1xuICB2YXIgaW50cyA9IEJ1ZmZlci5hbGxvYyg1KTtcbiAgdmFyIGtleWlkID0gQnVmZmVyLmZyb20oaGVhZGVyLmtleWlkIHx8IFtdKTtcbiAgaWYgKGtleWlkLmxlbmd0aCA+IDI1NSkge1xuICAgIHRocm93IG5ldyBFcnJvcigna2V5aWQgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgaW50cy53cml0ZVVJbnRCRShoZWFkZXIucnMsIDAsIDQpO1xuICBpbnRzLndyaXRlVUludEJFKGtleWlkLmxlbmd0aCwgNCwgMSk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtoZWFkZXIuc2FsdCwgaW50cywga2V5aWRdKTtcbn1cblxuLyoqXG4gKiBFbmNyeXB0IHNvbWUgYnl0ZXMuICBUaGlzIHVzZXMgdGhlIHBhcmFtZXRlcnMgdG8gZGV0ZXJtaW5lIHRoZSBrZXkgYW5kIGJsb2NrXG4gKiBzaXplLCB3aGljaCBhcmUgZGVzY3JpYmVkIGluIHRoZSBkcmFmdC5cbiAqXG4gKiB8cGFyYW1zLnZlcnNpb258IGNvbnRhaW5zIHRoZSB2ZXJzaW9uIG9mIGVuY29kaW5nIHRvIHVzZTogYWVzMTI4Z2NtIGlzIHRoZSBsYXRlc3QsXG4gKiBidXQgYWVzZ2NtIGlzIGFsc28gYWNjZXB0ZWQgKHRob3VnaCB0aGUgbGF0dGVyIHR3byBtaWdodFxuICogZGlzYXBwZWFyIGluIGEgZnV0dXJlIHJlbGVhc2UpLiAgSWYgb21pdHRlZCwgYXNzdW1lIGFlczEyOGdjbS5cbiAqXG4gKiBJZiB8cGFyYW1zLmtleXwgaXMgc3BlY2lmaWVkLCB0aGF0IHZhbHVlIGlzIHVzZWQgYXMgdGhlIGtleS5cbiAqXG4gKiBGb3IgRGlmZmllLUhlbGxtYW4gKFdlYlB1c2gpLCB8cGFyYW1zLmRofCBpbmNsdWRlcyB0aGUgcHVibGljIGtleSBvZiB0aGVcbiAqIHJlY2VpdmVyLiAgfHBhcmFtcy5wcml2YXRlS2V5fCBpcyB1c2VkIHRvIGVzdGFibGlzaCBhIHNoYXJlZCBzZWNyZXQuICBLZXlcbiAqIHBhaXJzIGNhbiBiZSBjcmVhdGVkIHVzaW5nIHxjcnlwdG8uY3JlYXRlRUNESCgpfC5cbiAqL1xuZnVuY3Rpb24gZW5jcnlwdChidWZmZXIsIHBhcmFtcywga2V5TG9va3VwQ2FsbGJhY2spIHsgIFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdidWZmZXIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICB9XG4gIHZhciBoZWFkZXIgPSBwYXJzZVBhcmFtcyhwYXJhbXMpO1xuICBpZiAoIWhlYWRlci5zYWx0KSB7XG4gICAgaGVhZGVyLnNhbHQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoS0VZX0xFTkdUSCk7XG4gIH1cblxuICB2YXIgcmVzdWx0O1xuICBpZiAoaGVhZGVyLnZlcnNpb24gPT09ICdhZXMxMjhnY20nKSB7XG4gICAgLy8gU2F2ZSB0aGUgREggcHVibGljIGtleSBpbiB0aGUgaGVhZGVyIHVubGVzcyBrZXlpZCBpcyBzZXQuXG4gICAgaWYgKGhlYWRlci5wcml2YXRlS2V5ICYmICFoZWFkZXIua2V5aWQpIHtcbiAgICAgIGhlYWRlci5rZXlpZCA9IGhlYWRlci5wcml2YXRlS2V5LmdldFB1YmxpY0tleSgpO1xuICAgIH1cbiAgICByZXN1bHQgPSB3cml0ZUhlYWRlcihoZWFkZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIGhlYWRlciBvbiBvdGhlciB2ZXJzaW9uc1xuICAgIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgfVxuXG4gIHZhciBrZXkgPSBkZXJpdmVLZXlBbmROb25jZShoZWFkZXIsIE1PREVfRU5DUllQVCwga2V5TG9va3VwQ2FsbGJhY2spO1xuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgcGFkU2l6ZSA9IFBBRF9TSVpFW2hlYWRlci52ZXJzaW9uXTtcbiAgdmFyIG92ZXJoZWFkID0gcGFkU2l6ZTtcbiAgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzMTI4Z2NtJykge1xuICAgIG92ZXJoZWFkICs9IFRBR19MRU5HVEg7XG4gIH1cbiAgdmFyIHBhZCA9IGlzTmFOKHBhcnNlSW50KHBhcmFtcy5wYWQsIDEwKSkgPyAwIDogcGFyc2VJbnQocGFyYW1zLnBhZCwgMTApO1xuXG4gIHZhciBjb3VudGVyID0gMDtcbiAgdmFyIGxhc3QgPSBmYWxzZTtcbiAgd2hpbGUgKCFsYXN0KSB7XG4gICAgLy8gUGFkIHNvIHRoYXQgYXQgbGVhc3Qgb25lIGRhdGEgYnl0ZSBpcyBpbiBhIGJsb2NrLlxuICAgIHZhciByZWNvcmRQYWQgPSBNYXRoLm1pbihoZWFkZXIucnMgLSBvdmVyaGVhZCAtIDEsIHBhZCk7XG4gICAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJykge1xuICAgICAgcmVjb3JkUGFkID0gTWF0aC5taW4oKDEgPDwgKHBhZFNpemUgKiA4KSkgLSAxLCByZWNvcmRQYWQpO1xuICAgIH1cbiAgICBpZiAocGFkID4gMCAmJiByZWNvcmRQYWQgPT09IDApIHtcbiAgICAgICsrcmVjb3JkUGFkOyAvLyBEZWFsIHdpdGggcGVydmVyc2UgY2FzZSBvZiBycz1vdmVyaGVhZCsxIHdpdGggcGFkZGluZy5cbiAgICB9XG4gICAgcGFkIC09IHJlY29yZFBhZDtcblxuICAgIHZhciBlbmQgPSBzdGFydCArIGhlYWRlci5ycyAtIG92ZXJoZWFkIC0gcmVjb3JkUGFkO1xuICAgIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICAgIC8vIFRoZSA+IGhlcmUgZW5zdXJlcyB0aGF0IHdlIHdyaXRlIG91dCBhIHBhZGRpbmctb25seSBibG9jayBhdCB0aGUgZW5kXG4gICAgICAvLyBvZiBhIGJ1ZmZlci5cbiAgICAgIGxhc3QgPSBlbmQgPiBidWZmZXIubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gZW5kID49IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGxhc3QgPSBsYXN0ICYmIHBhZCA8PSAwO1xuICAgIHZhciBibG9jayA9IGVuY3J5cHRSZWNvcmQoa2V5LCBjb3VudGVyLCBidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRQYWQsIGhlYWRlciwgbGFzdCk7XG4gICAgcmVzdWx0ID0gQnVmZmVyLmNvbmNhdChbcmVzdWx0LCBibG9ja10pO1xuXG4gICAgc3RhcnQgPSBlbmQ7XG4gICAgKytjb3VudGVyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZihvYmplY3QpID09PSAnZnVuY3Rpb24nO1xuIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlY3J5cHQ6IGRlY3J5cHQsXG4gIGVuY3J5cHQ6IGVuY3J5cHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/http_ece@1.2.0/node_modules/http_ece/ece.js\n");

/***/ })

};
;