"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@nangohq+node@0.42.10";
exports.ids = ["vendor-chunks/@nangohq+node@0.42.10"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Nango: () => (/* binding */ Nango),\n/* harmony export */   SyncConfigType: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_3__.SyncConfigType),\n/* harmony export */   SyncType: () => (/* binding */ SyncType),\n/* harmony export */   getUserAgent: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_2__.getUserAgent),\n/* harmony export */   prodHost: () => (/* binding */ prodHost),\n/* harmony export */   stagingHost: () => (/* binding */ stagingHost)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/.pnpm/axios@1.7.4/node_modules/axios/lib/axios.js\");\n/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:https */ \"node:https\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/utils.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/types.js\");\n\n\n\n\nconst stagingHost = 'https://api-staging.nango.dev';\nconst prodHost = 'https://api.nango.dev';\n\n\nvar SyncType;\n(function (SyncType) {\n    SyncType[\"INITIAL\"] = \"INITIAL\";\n    SyncType[\"INCREMENTAL\"] = \"INCREMENTAL\";\n})(SyncType || (SyncType = {}));\nconst defaultHttpsAgent = new node_https__WEBPACK_IMPORTED_MODULE_1__.Agent({ keepAlive: true });\nclass Nango {\n    serverUrl;\n    secretKey;\n    connectionId;\n    providerConfigKey;\n    isSync = false;\n    dryRun = false;\n    activityLogId;\n    userAgent;\n    http;\n    constructor(config, { userAgent } = {}) {\n        config.host = config.host || prodHost;\n        this.serverUrl = config.host;\n        if (this.serverUrl.slice(-1) === '/') {\n            this.serverUrl = this.serverUrl.slice(0, -1);\n        }\n        if (!config.secretKey) {\n            throw new Error('You must specify a secret key (cf. documentation).');\n        }\n        try {\n            new URL(this.serverUrl);\n        }\n        catch {\n            throw new Error(`Invalid URL provided for the Nango host: ${this.serverUrl}`);\n        }\n        this.secretKey = config.secretKey;\n        this.connectionId = config.connectionId || '';\n        this.providerConfigKey = config.providerConfigKey || '';\n        if (config.isSync) {\n            this.isSync = config.isSync;\n        }\n        if (config.dryRun) {\n            this.dryRun = config.dryRun;\n        }\n        if (config.activityLogId) {\n            this.activityLogId = config.activityLogId;\n        }\n        this.userAgent = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.getUserAgent)(userAgent);\n        this.http = axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create({\n            httpsAgent: defaultHttpsAgent,\n            headers: {\n                'User-Agent': this.userAgent\n            }\n        });\n    }\n    /**\n     * =======\n     * INTEGRATIONS\n     *      LIST\n     *      GET\n     *      CREATE\n     *      UPDATE\n     *      DELETE\n     * =======\n     */\n    /**\n     * Returns a list of integrations\n     * @returns A promise that resolves with an object containing an array of integration configurations\n     */\n    async listIntegrations() {\n        const url = `${this.serverUrl}/config`;\n        const response = await this.http.get(url, { headers: this.enrichHeaders({}) });\n        return response.data;\n    }\n    /**\n     * Returns a specific integration\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param includeIntegrationCredentials - An optional flag indicating whether to include integration credentials in the response. Default is false\n     * @returns A promise that resolves with an object containing an integration configuration\n     */\n    async getIntegration(providerConfigKey, includeIntegrationCredentials = false) {\n        const url = `${this.serverUrl}/config/${providerConfigKey}`;\n        const response = await this.http.get(url, { headers: this.enrichHeaders({}), params: { include_creds: includeIntegrationCredentials } });\n        return response.data;\n    }\n    /**\n     * Creates a new integration with the specified provider and configuration key\n     * Optionally, you can provide credentials for the integration\n     * @param provider - The provider of the integration\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param credentials - Optional credentials for the integration\n     * @returns A promise that resolves with the created integration configuration\n     */\n    async createIntegration(provider, providerConfigKey, credentials) {\n        const url = `${this.serverUrl}/config`;\n        const response = await this.http.post(url, { provider, provider_config_key: providerConfigKey, ...credentials }, { headers: this.enrichHeaders({}) });\n        return response.data;\n    }\n    /**\n     * Updates an integration with the specified provider and configuration key\n     * Only integrations using OAuth 1 & 2 can be updated, not integrations using API keys & Basic auth (because there is nothing to update for them)\n     * @param provider - The Nango API Configuration (cf. [providers.yaml](https://github.com/NangoHQ/nango/blob/master/packages/shared/providers.yaml))\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param credentials - Optional credentials to include, depending on the specific integration that you want to update\n     * @returns A promise that resolves with the updated integration configuration object\n     */\n    async updateIntegration(provider, providerConfigKey, credentials) {\n        const url = `${this.serverUrl}/config`;\n        const response = await this.http.put(url, { provider, provider_config_key: providerConfigKey, ...credentials }, { headers: this.enrichHeaders({}) });\n        return response.data;\n    }\n    /**\n     * Deletes an integration with the specified configuration key\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @returns A promise that resolves with the response from the server\n     */\n    async deleteIntegration(providerConfigKey) {\n        const url = `${this.serverUrl}/config/${providerConfigKey}`;\n        return await this.http.delete(url, { headers: this.enrichHeaders({}) });\n    }\n    /**\n     * =======\n     * CONNECTIONS\n     *      LIST\n     *      GET\n     *      IMPORT / CREATE -- DEPRECATED use REST API\n     *      GET TOKEN\n     *      GET RAW TOKEN\n     *      GET METADATA\n     *      SET METADATA\n     *      DELETE\n     * =======\n     */\n    /**\n     * Returns a list of connections, optionally filtered by connection ID\n     * @param connectionId - Optional. The ID of the connection to retrieve details of\n     * @returns A promise that resolves with an array of connection objects\n     */\n    async listConnections(connectionId) {\n        const response = await this.listConnectionDetails(connectionId);\n        return response.data;\n    }\n    /**\n     * Returns a connection object, which also contains access credentials and full credentials payload\n     * @param providerConfigKey - The integration ID used to create the connection (i.e Unique Key)\n     * @param connectionId - This is the unique connection identifier used to identify this connection\n     * @param forceRefresh - Optional. When set to true, this obtains a new access token from the provider before the current token has expired\n     * @param refreshToken - Optional. When set to true, this returns the refresh token as part of the response\n     * @returns A promise that resolves with a connection object\n     */\n    async getConnection(providerConfigKey, connectionId, forceRefresh, refreshToken) {\n        const response = await this.getConnectionDetails(providerConfigKey, connectionId, forceRefresh, refreshToken);\n        return response.data;\n    }\n    /**\n     * @deprecated This method has been deprecated, please use the REST API to import a connection.\n     */\n    importConnection(_connectionArgs) {\n        throw new Error('This method has been deprecated, please use the REST API to import a connection.');\n    }\n    /**\n     * @deprecated This method has been deprecated, please use the REST API to import a connection.\n     */\n    createConnection(_connectionArgs) {\n        throw new Error('This method has been deprecated, please use the REST API to create a connection.');\n    }\n    /**\n     * For OAuth 2: returns the access token directly as a string\n     * For OAuth 2: If you want to obtain a new refresh token from the provider before the current token has expired,\n     * you can set the forceRefresh argument to true\n     * For OAuth 1: returns an object with 'oAuthToken' and 'oAuthTokenSecret' fields\n     * @param providerConfigKey - The integration ID used to create the connection (i.e Unique Key)\n     * @param connectionId - This is the unique connection identifier used to identify this connection\n     * @param forceRefresh - Optional. When set to true, this obtains a new access token from the provider before the current token has expired\n     */\n    async getToken(providerConfigKey, connectionId, forceRefresh) {\n        const response = await this.getConnectionDetails(providerConfigKey, connectionId, forceRefresh);\n        switch (response.data.credentials.type) {\n            case 'OAUTH2':\n                return response.data.credentials.access_token;\n            case 'OAUTH1':\n                return { oAuthToken: response.data.credentials.oauth_token, oAuthTokenSecret: response.data.credentials.oauth_token_secret };\n            default:\n                return response.data.credentials;\n        }\n    }\n    /**\n     * Get the full (fresh) credentials payload returned by the external API,\n     * which also contains access credentials\n     * @param providerConfigKey - The integration ID used to create the connection (i.e Unique Key)\n     * @param connectionId - This is the unique connection identifier used to identify this connection\n     * @param forceRefresh - Optional. When set to true, this obtains a new access token from the provider before the current token has expired\n     * @returns A promise that resolves with the raw token response\n     */\n    async getRawTokenResponse(providerConfigKey, connectionId, forceRefresh) {\n        const response = await this.getConnectionDetails(providerConfigKey, connectionId, forceRefresh);\n        const credentials = response.data.credentials;\n        return credentials.raw;\n    }\n    /**\n     * Retrieves metadata for a given provider configuration key and connection ID\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param connectionId - The ID of the connection for which to retrieve metadata\n     * @returns A promise that resolves with the retrieved metadata\n     */\n    async getMetadata(providerConfigKey, connectionId) {\n        if (!providerConfigKey) {\n            throw new Error('Provider Config Key is required');\n        }\n        if (!connectionId) {\n            throw new Error('Connection Id is required');\n        }\n        const response = await this.getConnectionDetails(providerConfigKey, connectionId, false, false, {\n            'Nango-Is-Sync': true,\n            'Nango-Is-Dry-Run': this.dryRun\n        });\n        return response.data.metadata;\n    }\n    /**\n     * Sets custom metadata for a connection\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param connectionId - The ID(s) of the connection(s) for which to set metadata\n     * @param metadata - The custom metadata to set\n     * @returns A promise that resolves with the Axios response from the server\n     */\n    async setMetadata(providerConfigKey, connectionId, metadata) {\n        if (!providerConfigKey) {\n            throw new Error('Provider Config Key is required');\n        }\n        if (!connectionId) {\n            throw new Error('Connection Id is required');\n        }\n        if (!metadata) {\n            throw new Error('Metadata is required');\n        }\n        const url = `${this.serverUrl}/connection/metadata`;\n        return this.http.post(url, { metadata, connection_id: connectionId, provider_config_key: providerConfigKey }, { headers: this.enrichHeaders() });\n    }\n    /**\n     * Edits custom metadata for a connection, only overriding specified properties, not the entire metadata\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param connectionId - The ID(s) of the connection(s) for which to update metadata\n     * @param metadata - The custom metadata to update\n     * @returns A promise that resolves with the Axios response from the server\n     */\n    async updateMetadata(providerConfigKey, connectionId, metadata) {\n        if (!providerConfigKey) {\n            throw new Error('Provider Config Key is required');\n        }\n        if (!connectionId) {\n            throw new Error('Connection Id is required');\n        }\n        if (!metadata) {\n            throw new Error('Metadata is required');\n        }\n        const url = `${this.serverUrl}/connection/metadata`;\n        return this.http.patch(url, { metadata, connection_id: connectionId, provider_config_key: providerConfigKey }, { headers: this.enrichHeaders() });\n    }\n    /**\n     * Deletes a specific connection\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param connectionId - The ID of the connection to be deleted\n     * @returns A promise that resolves with the Axios response from the server\n     */\n    async deleteConnection(providerConfigKey, connectionId) {\n        const url = `${this.serverUrl}/connection/${connectionId}?provider_config_key=${providerConfigKey}`;\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        return this.http.delete(url, { headers: this.enrichHeaders(headers) });\n    }\n    /**\n     * =======\n     * SCRIPTS\n     *      CONFIG\n     * =======\n     */\n    /**\n     * Retrieves the configuration for all integration scripts\n     * @returns A promise that resolves with an array of configuration objects for all integration scripts\n     */\n    async getScriptsConfig() {\n        const url = `${this.serverUrl}/scripts/config`;\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        const response = await this.http.get(url, { headers: this.enrichHeaders(headers) });\n        return response.data;\n    }\n    /**\n     * =======\n     * SYNCS\n     *      GET RECORDS\n     *      TRIGGER\n     *      START\n     *      PAUSE\n     *      STATUS\n     *      GET ENVIRONMENT VARIABLES\n     * =======\n     */\n    /**\n     * Returns the synced data, ordered by modification date ascending\n     * If some records are updated while you paginate through this endpoint, you might see these records multiple times\n     * @param config - Configuration object for listing records\n     * @returns A promise that resolves with an object containing an array of records and a cursor for pagination\n     */\n    async listRecords(config) {\n        const { connectionId, providerConfigKey, model, delta, modifiedAfter, limit, filter, cursor } = config;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.validateSyncRecordConfiguration)(config);\n        const url = `${this.serverUrl}/records/?model=${model}${delta || modifiedAfter ? `&modified_after=${modifiedAfter || delta}` : ''}${limit ? `&limit=${limit}` : ''}${filter ? `&filter=${filter}` : ''}${cursor ? `&cursor=${cursor}` : ''}`;\n        const headers = {\n            'Connection-Id': connectionId,\n            'Provider-Config-Key': providerConfigKey\n        };\n        const options = {\n            headers: this.enrichHeaders(headers)\n        };\n        const response = await this.http.get(url, options);\n        return response.data;\n    }\n    /**\n     * Triggers an additional, one-off execution of specified sync(s) for a given connection or all applicable connections if no connection is specified\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param syncs - An optional array of sync names to trigger. If empty, all applicable syncs will be triggered\n     * @param connectionId - An optional ID of the connection for which to trigger the syncs. If not provided, syncs will be triggered for all applicable connections\n     * @param fullResync - An optional flag indicating whether to perform a full resynchronization. Default is false\n     * @returns A promise that resolves when the sync trigger request is sent\n     */\n    async triggerSync(providerConfigKey, syncs, connectionId, fullResync) {\n        const url = `${this.serverUrl}/sync/trigger`;\n        if (typeof syncs === 'string') {\n            throw new Error('Syncs must be an array of strings. If it is a single sync, please wrap it in an array.');\n        }\n        const body = {\n            syncs: syncs || [],\n            provider_config_key: providerConfigKey,\n            connection_id: connectionId,\n            full_resync: fullResync\n        };\n        return this.http.post(url, body, { headers: this.enrichHeaders() });\n    }\n    /**\n     * Starts the schedule of specified sync(s) for a given connection or all applicable connections if no connection is specified. Upon starting the schedule, the sync will execute immediately and then continue to run at the specified frequency. If the schedule was already started, this will have no effect.\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param syncs - An optional array of sync names to start. If empty, all applicable syncs will be started\n     * @param connectionId - An optional ID of the connection for which to start the syncs. If not provided, syncs will be started for all applicable connections\n     * @returns A promise that resolves when the sync start request is sent\n     */\n    async startSync(providerConfigKey, syncs, connectionId) {\n        if (!providerConfigKey) {\n            throw new Error('Provider Config Key is required');\n        }\n        if (!syncs) {\n            throw new Error('Sync is required');\n        }\n        if (typeof syncs === 'string') {\n            throw new Error('Syncs must be an array of strings. If it is a single sync, please wrap it in an array.');\n        }\n        const body = {\n            syncs: syncs || [],\n            provider_config_key: providerConfigKey,\n            connection_id: connectionId\n        };\n        const url = `${this.serverUrl}/sync/start`;\n        return this.http.post(url, body, { headers: this.enrichHeaders() });\n    }\n    /**\n     * Pauses the schedule of specified sync(s) for a given connection or all applicable connections\n     * @param providerConfigKey -The key identifying the provider configuration on Nango\n     * @param syncs - An optional array of sync names to pause. If empty, all applicable syncs will be paused\n     * @param connectionId - An optional ID of the connection for which to pause the syncs. If not provided, syncs will be paused for all applicable connections\n     * @returns A promise that resolves when the sync pause request is sent\n     */\n    async pauseSync(providerConfigKey, syncs, connectionId) {\n        if (!providerConfigKey) {\n            throw new Error('Provider Config Key is required');\n        }\n        if (!syncs) {\n            throw new Error('Sync is required');\n        }\n        if (typeof syncs === 'string') {\n            throw new Error('Syncs must be an array of strings. If it is a single sync, please wrap it in an array.');\n        }\n        const url = `${this.serverUrl}/sync/pause`;\n        const body = {\n            syncs: syncs || [],\n            provider_config_key: providerConfigKey,\n            connection_id: connectionId\n        };\n        return this.http.post(url, body, { headers: this.enrichHeaders() });\n    }\n    /**\n     * Get the status of specified sync(s) for a given connection or all applicable connections\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param syncs - An array of sync names to get status for, or '*' to get status for all syncs\n     * @param connectionId - An optional ID of the connection for which to get sync status. If not provided, status for all applicable connections will be retrieved\n     * @returns A promise that resolves with the status of the specified sync(s)\n     */\n    async syncStatus(providerConfigKey, syncs, connectionId) {\n        if (!providerConfigKey) {\n            throw new Error('Provider Config Key is required');\n        }\n        if (!syncs) {\n            throw new Error('Sync is required');\n        }\n        if (typeof syncs === 'string' && syncs !== '*') {\n            throw new Error('Syncs must be an array of strings. If it is a single sync, please wrap it in an array.');\n        }\n        const url = `${this.serverUrl}/sync/status`;\n        const params = {\n            syncs: syncs === '*' ? '*' : syncs.join(','),\n            provider_config_key: providerConfigKey,\n            connection_id: connectionId\n        };\n        const response = await this.http.get(url, { headers: this.enrichHeaders(), params });\n        return response.data;\n    }\n    /**\n     * Override a syncâ€™s default frequency for a specific connection, or revert to the default frequency\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param sync - The name of the sync to update\n     * @param connectionId - The ID of the connection for which to update the sync frequency\n     * @param frequency - The new frequency to set for the sync, or null to revert to the default frequency\n     * @returns A promise that resolves with the response data after updating the sync frequency\n     */\n    async updateSyncConnectionFrequency(providerConfigKey, sync, connectionId, frequency) {\n        if (!providerConfigKey) {\n            throw new Error('Provider Config Key is required');\n        }\n        if (typeof sync === 'string') {\n            throw new Error('Sync must be a string.');\n        }\n        if (typeof connectionId === 'string') {\n            throw new Error('ConnectionId must be a string.');\n        }\n        if (typeof frequency !== 'string' && frequency !== null) {\n            throw new Error('Frequency must be a string or null.');\n        }\n        const url = `${this.serverUrl}/sync/update-connection-frequency`;\n        const params = {\n            sync,\n            provider_config_key: providerConfigKey,\n            connection_id: connectionId,\n            frequency\n        };\n        const response = await this.http.put(url, { headers: this.enrichHeaders(), params });\n        return response.data;\n    }\n    /**\n     * Retrieve the environment variables as added in the Nango dashboard\n     * @returns A promise that resolves with an array of environment variables\n     */\n    async getEnvironmentVariables() {\n        const url = `${this.serverUrl}/environment-variables`;\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        const response = await this.http.get(url, { headers: this.enrichHeaders(headers) });\n        if (!response.data) {\n            return [];\n        }\n        return response.data;\n    }\n    /**\n     * =======\n     * ACTIONS\n     *      TRIGGER\n     * =======\n     */\n    /**\n     * Triggers an action for a connection\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param connectionId - The ID of the connection for which the action should be triggered\n     * @param actionName - The name of the action to trigger\n     * @param input - An optional input data for the action\n     * @returns A promise that resolves with an object containing the response data from the triggered action\n     */\n    async triggerAction(providerConfigKey, connectionId, actionName, input) {\n        const url = `${this.serverUrl}/action/trigger`;\n        const headers = {\n            'Connection-Id': connectionId,\n            'Provider-Config-Key': providerConfigKey\n        };\n        const body = {\n            action_name: actionName,\n            input\n        };\n        const response = await this.http.post(url, body, { headers: this.enrichHeaders(headers) });\n        return response.data;\n    }\n    /**\n     * =======\n     * PROXY\n     *      GET\n     *      POST\n     *      PUT\n     *      PATCH\n     *      DELETE\n     * =======\n     */\n    /**\n     * Sends a proxied HTTP request based on the provided configuration\n     * @param config - The configuration object for the proxy request\n     * @returns A promise that resolves with the response from the proxied request\n     */\n    async proxy(config) {\n        if (!config.connectionId && this.connectionId) {\n            config.connectionId = this.connectionId;\n        }\n        if (!config.providerConfigKey && this.providerConfigKey) {\n            config.providerConfigKey = this.providerConfigKey;\n        }\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.validateProxyConfiguration)(config);\n        const { providerConfigKey, connectionId, method, retries, headers: customHeaders, baseUrlOverride, decompress, retryOn } = config;\n        const url = `${this.serverUrl}/proxy${config.endpoint[0] === '/' ? '' : '/'}${config.endpoint}`;\n        const customPrefixedHeaders = customHeaders && Object.keys(customHeaders).length > 0\n            ? Object.keys(customHeaders).reduce((acc, key) => {\n                acc[`Nango-Proxy-${key}`] = customHeaders[key];\n                return acc;\n            }, {})\n            : {};\n        const headers = {\n            'Connection-Id': connectionId,\n            'Provider-Config-Key': providerConfigKey,\n            'Base-Url-Override': baseUrlOverride || '',\n            'Nango-Is-Sync': this.isSync,\n            'Nango-Is-Dry-Run': this.dryRun,\n            'Nango-Activity-Log-Id': this.activityLogId || '',\n            ...customPrefixedHeaders\n        };\n        if (customHeaders?.['Content-Type']) {\n            headers['Content-Type'] = customHeaders['Content-Type'];\n        }\n        if (retries) {\n            headers['Retries'] = retries;\n        }\n        if (decompress) {\n            headers['Decompress'] = decompress;\n        }\n        if (retryOn) {\n            headers['Retry-On'] = retryOn.join(',');\n        }\n        const options = {\n            headers: this.enrichHeaders(headers)\n        };\n        if (config.params) {\n            options.params = config.params;\n        }\n        if (config.paramsSerializer) {\n            options.paramsSerializer = config.paramsSerializer;\n        }\n        if (config.responseType) {\n            options.responseType = config.responseType;\n        }\n        if (method?.toUpperCase() === 'POST') {\n            return this.http.post(url, config.data, options);\n        }\n        else if (method?.toUpperCase() === 'PATCH') {\n            return this.http.patch(url, config.data, options);\n        }\n        else if (method?.toUpperCase() === 'PUT') {\n            return this.http.put(url, config.data, options);\n        }\n        else if (method?.toUpperCase() === 'DELETE') {\n            return this.http.delete(url, options);\n        }\n        else {\n            return this.http.get(url, options);\n        }\n    }\n    /**\n     * Sends a GET request using the proxy based on the provided configuration\n     * @param config - The configuration object for the GET request\n     * @returns A promise that resolves with the response from the GET request\n     */\n    async get(config) {\n        return this.proxy({\n            ...config,\n            method: 'GET'\n        });\n    }\n    /**\n     * Sends a POST request using the proxy based on the provided configuration\n     * @param config - The configuration object for the POST request\n     * @returns A promise that resolves with the response from the POST request\n     */\n    async post(config) {\n        return this.proxy({\n            ...config,\n            method: 'POST'\n        });\n    }\n    /**\n     * Sends a PATCH request using the proxy based on the provided configuration\n     * @param config - The configuration object for the PATCH request\n     * @returns A promise that resolves with the response from the PATCH request\n     */\n    async patch(config) {\n        return this.proxy({\n            ...config,\n            method: 'PATCH'\n        });\n    }\n    /**\n     * Sends a DELETE request using the proxy based on the provided configuration\n     * @param config - The configuration object for the DELETE request\n     * @returns A promise that resolves with the response from the DELETE request\n     */\n    async delete(config) {\n        return this.proxy({\n            ...config,\n            method: 'DELETE'\n        });\n    }\n    // -- Webhooks\n    /**\n     *\n     * Verify incoming webhooks signature\n     *\n     * @param signatureInHeader - The value in the header X-Nango-Signature\n     * @param jsonPayload - The HTTP body as JSON\n     * @returns Whether the signature is valid\n     */\n    verifyWebhookSignature(signatureInHeader, jsonPayload) {\n        return (node_crypto__WEBPACK_IMPORTED_MODULE_0__.createHash('sha256')\n            .update(`${this.secretKey}${JSON.stringify(jsonPayload)}`)\n            .digest('hex') === signatureInHeader);\n    }\n    /**\n     * Retrieves details of a specific connection\n     * @param providerConfigKey - The key identifying the provider configuration on Nango\n     * @param connectionId - The ID of the connection for which to retrieve connection details\n     * @param forceRefresh - An optional flag indicating whether to force a refresh of the access tokens. Defaults to false\n     * @param refreshToken - An optional flag indicating whether to send the refresh token as part of the response. Defaults to false\n     * @param additionalHeader - Optional. Additional headers to include in the request\n     * @returns A promise that resolves with the response containing connection details\n     */\n    async getConnectionDetails(providerConfigKey, connectionId, forceRefresh = false, refreshToken = false, additionalHeader = {}) {\n        const url = `${this.serverUrl}/connection/${connectionId}`;\n        const headers = {\n            'Content-Type': 'application/json',\n            'Nango-Is-Sync': this.isSync,\n            'Nango-Is-Dry-Run': this.dryRun\n        };\n        if (additionalHeader) {\n            Object.assign(headers, additionalHeader);\n        }\n        const params = {\n            provider_config_key: providerConfigKey,\n            force_refresh: forceRefresh,\n            refresh_token: refreshToken\n        };\n        return this.http.get(url, { params: params, headers: this.enrichHeaders(headers) });\n    }\n    /**\n     * Retrieves details of all connections from the server or details of a specific connection if a connection ID is provided\n     * @param connectionId - Optional. This is the unique connection identifier used to identify this connection\n     * @returns A promise that resolves with the response containing connection details\n     */\n    async listConnectionDetails(connectionId) {\n        let url = `${this.serverUrl}/connection?`;\n        if (connectionId) {\n            url = url.concat(`connectionId=${connectionId}`);\n        }\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        return this.http.get(url, { headers: this.enrichHeaders(headers) });\n    }\n    /**\n     * Enriches the headers with the Authorization token\n     * @param headers - Optional. The headers to enrich\n     * @returns The enriched headers\n     */\n    enrichHeaders(headers = {}) {\n        headers['Authorization'] = 'Bearer ' + this.secretKey;\n        return headers;\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5hbmdvaHErbm9kZUAwLjQyLjEwL25vZGVfbW9kdWxlcy9AbmFuZ29ocS9ub2RlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDUDtBQUNLO0FBQ3dFO0FBQ2hHO0FBQ0E7QUFDb0I7QUFDZTtBQUNuQztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCLDhCQUE4Qiw2Q0FBVyxHQUFHLGlCQUFpQjtBQUN0RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdURBQVk7QUFDckMsb0JBQW9CLDZDQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMsb0RBQW9ELDhCQUE4QixHQUFHO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlLFVBQVUsa0JBQWtCO0FBQ2xFLG9EQUFvRCw4QkFBOEIsYUFBYSxnREFBZ0Q7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDLHFEQUFxRCxrRUFBa0UsSUFBSSw4QkFBOEIsR0FBRztBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMsb0RBQW9ELGtFQUFrRSxJQUFJLDhCQUE4QixHQUFHO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZSxVQUFVLGtCQUFrQjtBQUNsRSw2Q0FBNkMsOEJBQThCLEdBQUc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QyxxQ0FBcUMsK0VBQStFLElBQUksK0JBQStCO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDLHNDQUFzQywrRUFBK0UsSUFBSSwrQkFBK0I7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlLGNBQWMsYUFBYSx1QkFBdUIsa0JBQWtCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQ0FBc0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNDQUFzQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNGQUFzRjtBQUN0RyxRQUFRLDBFQUErQjtBQUN2Qyx1QkFBdUIsZUFBZSxrQkFBa0IsTUFBTSxFQUFFLDRDQUE0Qyx1QkFBdUIsT0FBTyxFQUFFLGtCQUFrQixNQUFNLE9BQU8sRUFBRSxvQkFBb0IsT0FBTyxPQUFPLEVBQUUsb0JBQW9CLE9BQU8sT0FBTztBQUNuUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1Q0FBdUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1Q0FBdUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsc0NBQXNDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHNDQUFzQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFFQUEwQjtBQUNsQyxnQkFBZ0IsaUhBQWlIO0FBQ2pJLHVCQUF1QixlQUFlLFFBQVEsc0NBQXNDLEVBQUUsZ0JBQWdCO0FBQ3RHO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQ087QUFDdkIsdUJBQXVCLGVBQWUsRUFBRSw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSTtBQUNqSSx1QkFBdUIsZUFBZSxjQUFjLGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0RBQXNEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFyYmxpc20vbmV4dGpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuYW5nb2hxK25vZGVAMC40Mi4xMC9ub2RlX21vZHVsZXMvQG5hbmdvaHEvbm9kZS9kaXN0L2luZGV4LmpzPzcxNDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ25vZGU6aHR0cHMnO1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50LCB2YWxpZGF0ZVByb3h5Q29uZmlndXJhdGlvbiwgdmFsaWRhdGVTeW5jUmVjb3JkQ29uZmlndXJhdGlvbiB9IGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0IGNvbnN0IHN0YWdpbmdIb3N0ID0gJ2h0dHBzOi8vYXBpLXN0YWdpbmcubmFuZ28uZGV2JztcbmV4cG9ydCBjb25zdCBwcm9kSG9zdCA9ICdodHRwczovL2FwaS5uYW5nby5kZXYnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcy5qcyc7XG5leHBvcnQgeyBnZXRVc2VyQWdlbnQgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCB2YXIgU3luY1R5cGU7XG4oZnVuY3Rpb24gKFN5bmNUeXBlKSB7XG4gICAgU3luY1R5cGVbXCJJTklUSUFMXCJdID0gXCJJTklUSUFMXCI7XG4gICAgU3luY1R5cGVbXCJJTkNSRU1FTlRBTFwiXSA9IFwiSU5DUkVNRU5UQUxcIjtcbn0pKFN5bmNUeXBlIHx8IChTeW5jVHlwZSA9IHt9KSk7XG5jb25zdCBkZWZhdWx0SHR0cHNBZ2VudCA9IG5ldyBodHRwcy5BZ2VudCh7IGtlZXBBbGl2ZTogdHJ1ZSB9KTtcbmV4cG9ydCBjbGFzcyBOYW5nbyB7XG4gICAgc2VydmVyVXJsO1xuICAgIHNlY3JldEtleTtcbiAgICBjb25uZWN0aW9uSWQ7XG4gICAgcHJvdmlkZXJDb25maWdLZXk7XG4gICAgaXNTeW5jID0gZmFsc2U7XG4gICAgZHJ5UnVuID0gZmFsc2U7XG4gICAgYWN0aXZpdHlMb2dJZDtcbiAgICB1c2VyQWdlbnQ7XG4gICAgaHR0cDtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHsgdXNlckFnZW50IH0gPSB7fSkge1xuICAgICAgICBjb25maWcuaG9zdCA9IGNvbmZpZy5ob3N0IHx8IHByb2RIb3N0O1xuICAgICAgICB0aGlzLnNlcnZlclVybCA9IGNvbmZpZy5ob3N0O1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJVcmwuc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyVXJsID0gdGhpcy5zZXJ2ZXJVcmwuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29uZmlnLnNlY3JldEtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgc2VjcmV0IGtleSAoY2YuIGRvY3VtZW50YXRpb24pLicpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgVVJMKHRoaXMuc2VydmVyVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVJMIHByb3ZpZGVkIGZvciB0aGUgTmFuZ28gaG9zdDogJHt0aGlzLnNlcnZlclVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlY3JldEtleSA9IGNvbmZpZy5zZWNyZXRLZXk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbklkID0gY29uZmlnLmNvbm5lY3Rpb25JZCB8fCAnJztcbiAgICAgICAgdGhpcy5wcm92aWRlckNvbmZpZ0tleSA9IGNvbmZpZy5wcm92aWRlckNvbmZpZ0tleSB8fCAnJztcbiAgICAgICAgaWYgKGNvbmZpZy5pc1N5bmMpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTeW5jID0gY29uZmlnLmlzU3luYztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmRyeVJ1bikge1xuICAgICAgICAgICAgdGhpcy5kcnlSdW4gPSBjb25maWcuZHJ5UnVuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuYWN0aXZpdHlMb2dJZCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eUxvZ0lkID0gY29uZmlnLmFjdGl2aXR5TG9nSWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQodXNlckFnZW50KTtcbiAgICAgICAgdGhpcy5odHRwID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgICAgICAgIGh0dHBzQWdlbnQ6IGRlZmF1bHRIdHRwc0FnZW50LFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdVc2VyLUFnZW50JzogdGhpcy51c2VyQWdlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqID09PT09PT1cbiAgICAgKiBJTlRFR1JBVElPTlNcbiAgICAgKiAgICAgIExJU1RcbiAgICAgKiAgICAgIEdFVFxuICAgICAqICAgICAgQ1JFQVRFXG4gICAgICogICAgICBVUERBVEVcbiAgICAgKiAgICAgIERFTEVURVxuICAgICAqID09PT09PT1cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBpbnRlZ3JhdGlvbnNcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIGludGVncmF0aW9uIGNvbmZpZ3VyYXRpb25zXG4gICAgICovXG4gICAgYXN5bmMgbGlzdEludGVncmF0aW9ucygpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJVcmx9L2NvbmZpZ2A7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwLmdldCh1cmwsIHsgaGVhZGVyczogdGhpcy5lbnJpY2hIZWFkZXJzKHt9KSB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzcGVjaWZpYyBpbnRlZ3JhdGlvblxuICAgICAqIEBwYXJhbSBwcm92aWRlckNvbmZpZ0tleSAtIFRoZSBrZXkgaWRlbnRpZnlpbmcgdGhlIHByb3ZpZGVyIGNvbmZpZ3VyYXRpb24gb24gTmFuZ29cbiAgICAgKiBAcGFyYW0gaW5jbHVkZUludGVncmF0aW9uQ3JlZGVudGlhbHMgLSBBbiBvcHRpb25hbCBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0byBpbmNsdWRlIGludGVncmF0aW9uIGNyZWRlbnRpYWxzIGluIHRoZSByZXNwb25zZS4gRGVmYXVsdCBpcyBmYWxzZVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gaW50ZWdyYXRpb24gY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGdldEludGVncmF0aW9uKHByb3ZpZGVyQ29uZmlnS2V5LCBpbmNsdWRlSW50ZWdyYXRpb25DcmVkZW50aWFscyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVXJsfS9jb25maWcvJHtwcm92aWRlckNvbmZpZ0tleX1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cC5nZXQodXJsLCB7IGhlYWRlcnM6IHRoaXMuZW5yaWNoSGVhZGVycyh7fSksIHBhcmFtczogeyBpbmNsdWRlX2NyZWRzOiBpbmNsdWRlSW50ZWdyYXRpb25DcmVkZW50aWFscyB9IH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnRlZ3JhdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgcHJvdmlkZXIgYW5kIGNvbmZpZ3VyYXRpb24ga2V5XG4gICAgICogT3B0aW9uYWxseSwgeW91IGNhbiBwcm92aWRlIGNyZWRlbnRpYWxzIGZvciB0aGUgaW50ZWdyYXRpb25cbiAgICAgKiBAcGFyYW0gcHJvdmlkZXIgLSBUaGUgcHJvdmlkZXIgb2YgdGhlIGludGVncmF0aW9uXG4gICAgICogQHBhcmFtIHByb3ZpZGVyQ29uZmlnS2V5IC0gVGhlIGtleSBpZGVudGlmeWluZyB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbiBvbiBOYW5nb1xuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyAtIE9wdGlvbmFsIGNyZWRlbnRpYWxzIGZvciB0aGUgaW50ZWdyYXRpb25cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjcmVhdGVkIGludGVncmF0aW9uIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVJbnRlZ3JhdGlvbihwcm92aWRlciwgcHJvdmlkZXJDb25maWdLZXksIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVXJsfS9jb25maWdgO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cC5wb3N0KHVybCwgeyBwcm92aWRlciwgcHJvdmlkZXJfY29uZmlnX2tleTogcHJvdmlkZXJDb25maWdLZXksIC4uLmNyZWRlbnRpYWxzIH0sIHsgaGVhZGVyczogdGhpcy5lbnJpY2hIZWFkZXJzKHt9KSB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYW4gaW50ZWdyYXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHByb3ZpZGVyIGFuZCBjb25maWd1cmF0aW9uIGtleVxuICAgICAqIE9ubHkgaW50ZWdyYXRpb25zIHVzaW5nIE9BdXRoIDEgJiAyIGNhbiBiZSB1cGRhdGVkLCBub3QgaW50ZWdyYXRpb25zIHVzaW5nIEFQSSBrZXlzICYgQmFzaWMgYXV0aCAoYmVjYXVzZSB0aGVyZSBpcyBub3RoaW5nIHRvIHVwZGF0ZSBmb3IgdGhlbSlcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXIgLSBUaGUgTmFuZ28gQVBJIENvbmZpZ3VyYXRpb24gKGNmLiBbcHJvdmlkZXJzLnlhbWxdKGh0dHBzOi8vZ2l0aHViLmNvbS9OYW5nb0hRL25hbmdvL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9wcm92aWRlcnMueWFtbCkpXG4gICAgICogQHBhcmFtIHByb3ZpZGVyQ29uZmlnS2V5IC0gVGhlIGtleSBpZGVudGlmeWluZyB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbiBvbiBOYW5nb1xuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyAtIE9wdGlvbmFsIGNyZWRlbnRpYWxzIHRvIGluY2x1ZGUsIGRlcGVuZGluZyBvbiB0aGUgc3BlY2lmaWMgaW50ZWdyYXRpb24gdGhhdCB5b3Ugd2FudCB0byB1cGRhdGVcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB1cGRhdGVkIGludGVncmF0aW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlSW50ZWdyYXRpb24ocHJvdmlkZXIsIHByb3ZpZGVyQ29uZmlnS2V5LCBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLnNlcnZlclVybH0vY29uZmlnYDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHAucHV0KHVybCwgeyBwcm92aWRlciwgcHJvdmlkZXJfY29uZmlnX2tleTogcHJvdmlkZXJDb25maWdLZXksIC4uLmNyZWRlbnRpYWxzIH0sIHsgaGVhZGVyczogdGhpcy5lbnJpY2hIZWFkZXJzKHt9KSB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gaW50ZWdyYXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb24ga2V5XG4gICAgICogQHBhcmFtIHByb3ZpZGVyQ29uZmlnS2V5IC0gVGhlIGtleSBpZGVudGlmeWluZyB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbiBvbiBOYW5nb1xuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZUludGVncmF0aW9uKHByb3ZpZGVyQ29uZmlnS2V5KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVXJsfS9jb25maWcvJHtwcm92aWRlckNvbmZpZ0tleX1gO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5odHRwLmRlbGV0ZSh1cmwsIHsgaGVhZGVyczogdGhpcy5lbnJpY2hIZWFkZXJzKHt9KSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogPT09PT09PVxuICAgICAqIENPTk5FQ1RJT05TXG4gICAgICogICAgICBMSVNUXG4gICAgICogICAgICBHRVRcbiAgICAgKiAgICAgIElNUE9SVCAvIENSRUFURSAtLSBERVBSRUNBVEVEIHVzZSBSRVNUIEFQSVxuICAgICAqICAgICAgR0VUIFRPS0VOXG4gICAgICogICAgICBHRVQgUkFXIFRPS0VOXG4gICAgICogICAgICBHRVQgTUVUQURBVEFcbiAgICAgKiAgICAgIFNFVCBNRVRBREFUQVxuICAgICAqICAgICAgREVMRVRFXG4gICAgICogPT09PT09PVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbm5lY3Rpb25zLCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IGNvbm5lY3Rpb24gSURcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIC0gT3B0aW9uYWwuIFRoZSBJRCBvZiB0aGUgY29ubmVjdGlvbiB0byByZXRyaWV2ZSBkZXRhaWxzIG9mXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBjb25uZWN0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q29ubmVjdGlvbnMoY29ubmVjdGlvbklkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5saXN0Q29ubmVjdGlvbkRldGFpbHMoY29ubmVjdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb25uZWN0aW9uIG9iamVjdCwgd2hpY2ggYWxzbyBjb250YWlucyBhY2Nlc3MgY3JlZGVudGlhbHMgYW5kIGZ1bGwgY3JlZGVudGlhbHMgcGF5bG9hZFxuICAgICAqIEBwYXJhbSBwcm92aWRlckNvbmZpZ0tleSAtIFRoZSBpbnRlZ3JhdGlvbiBJRCB1c2VkIHRvIGNyZWF0ZSB0aGUgY29ubmVjdGlvbiAoaS5lIFVuaXF1ZSBLZXkpXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCAtIFRoaXMgaXMgdGhlIHVuaXF1ZSBjb25uZWN0aW9uIGlkZW50aWZpZXIgdXNlZCB0byBpZGVudGlmeSB0aGlzIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gT3B0aW9uYWwuIFdoZW4gc2V0IHRvIHRydWUsIHRoaXMgb2J0YWlucyBhIG5ldyBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgcHJvdmlkZXIgYmVmb3JlIHRoZSBjdXJyZW50IHRva2VuIGhhcyBleHBpcmVkXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiAtIE9wdGlvbmFsLiBXaGVuIHNldCB0byB0cnVlLCB0aGlzIHJldHVybnMgdGhlIHJlZnJlc2ggdG9rZW4gYXMgcGFydCBvZiB0aGUgcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgY29ubmVjdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb25uZWN0aW9uKHByb3ZpZGVyQ29uZmlnS2V5LCBjb25uZWN0aW9uSWQsIGZvcmNlUmVmcmVzaCwgcmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0aW9uRGV0YWlscyhwcm92aWRlckNvbmZpZ0tleSwgY29ubmVjdGlvbklkLCBmb3JjZVJlZnJlc2gsIHJlZnJlc2hUb2tlbik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRoZSBSRVNUIEFQSSB0byBpbXBvcnQgYSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGltcG9ydENvbm5lY3Rpb24oX2Nvbm5lY3Rpb25BcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aGUgUkVTVCBBUEkgdG8gaW1wb3J0IGEgY29ubmVjdGlvbi4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aGUgUkVTVCBBUEkgdG8gaW1wb3J0IGEgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGVDb25uZWN0aW9uKF9jb25uZWN0aW9uQXJncykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdGhlIFJFU1QgQVBJIHRvIGNyZWF0ZSBhIGNvbm5lY3Rpb24uJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBPQXV0aCAyOiByZXR1cm5zIHRoZSBhY2Nlc3MgdG9rZW4gZGlyZWN0bHkgYXMgYSBzdHJpbmdcbiAgICAgKiBGb3IgT0F1dGggMjogSWYgeW91IHdhbnQgdG8gb2J0YWluIGEgbmV3IHJlZnJlc2ggdG9rZW4gZnJvbSB0aGUgcHJvdmlkZXIgYmVmb3JlIHRoZSBjdXJyZW50IHRva2VuIGhhcyBleHBpcmVkLFxuICAgICAqIHlvdSBjYW4gc2V0IHRoZSBmb3JjZVJlZnJlc2ggYXJndW1lbnQgdG8gdHJ1ZVxuICAgICAqIEZvciBPQXV0aCAxOiByZXR1cm5zIGFuIG9iamVjdCB3aXRoICdvQXV0aFRva2VuJyBhbmQgJ29BdXRoVG9rZW5TZWNyZXQnIGZpZWxkc1xuICAgICAqIEBwYXJhbSBwcm92aWRlckNvbmZpZ0tleSAtIFRoZSBpbnRlZ3JhdGlvbiBJRCB1c2VkIHRvIGNyZWF0ZSB0aGUgY29ubmVjdGlvbiAoaS5lIFVuaXF1ZSBLZXkpXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCAtIFRoaXMgaXMgdGhlIHVuaXF1ZSBjb25uZWN0aW9uIGlkZW50aWZpZXIgdXNlZCB0byBpZGVudGlmeSB0aGlzIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gT3B0aW9uYWwuIFdoZW4gc2V0IHRvIHRydWUsIHRoaXMgb2J0YWlucyBhIG5ldyBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgcHJvdmlkZXIgYmVmb3JlIHRoZSBjdXJyZW50IHRva2VuIGhhcyBleHBpcmVkXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VG9rZW4ocHJvdmlkZXJDb25maWdLZXksIGNvbm5lY3Rpb25JZCwgZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0aW9uRGV0YWlscyhwcm92aWRlckNvbmZpZ0tleSwgY29ubmVjdGlvbklkLCBmb3JjZVJlZnJlc2gpO1xuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLmRhdGEuY3JlZGVudGlhbHMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnT0FVVEgyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICBjYXNlICdPQVVUSDEnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG9BdXRoVG9rZW46IHJlc3BvbnNlLmRhdGEuY3JlZGVudGlhbHMub2F1dGhfdG9rZW4sIG9BdXRoVG9rZW5TZWNyZXQ6IHJlc3BvbnNlLmRhdGEuY3JlZGVudGlhbHMub2F1dGhfdG9rZW5fc2VjcmV0IH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmNyZWRlbnRpYWxzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZnVsbCAoZnJlc2gpIGNyZWRlbnRpYWxzIHBheWxvYWQgcmV0dXJuZWQgYnkgdGhlIGV4dGVybmFsIEFQSSxcbiAgICAgKiB3aGljaCBhbHNvIGNvbnRhaW5zIGFjY2VzcyBjcmVkZW50aWFsc1xuICAgICAqIEBwYXJhbSBwcm92aWRlckNvbmZpZ0tleSAtIFRoZSBpbnRlZ3JhdGlvbiBJRCB1c2VkIHRvIGNyZWF0ZSB0aGUgY29ubmVjdGlvbiAoaS5lIFVuaXF1ZSBLZXkpXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCAtIFRoaXMgaXMgdGhlIHVuaXF1ZSBjb25uZWN0aW9uIGlkZW50aWZpZXIgdXNlZCB0byBpZGVudGlmeSB0aGlzIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gT3B0aW9uYWwuIFdoZW4gc2V0IHRvIHRydWUsIHRoaXMgb2J0YWlucyBhIG5ldyBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgcHJvdmlkZXIgYmVmb3JlIHRoZSBjdXJyZW50IHRva2VuIGhhcyBleHBpcmVkXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmF3IHRva2VuIHJlc3BvbnNlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmF3VG9rZW5SZXNwb25zZShwcm92aWRlckNvbmZpZ0tleSwgY29ubmVjdGlvbklkLCBmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldENvbm5lY3Rpb25EZXRhaWxzKHByb3ZpZGVyQ29uZmlnS2V5LCBjb25uZWN0aW9uSWQsIGZvcmNlUmVmcmVzaCk7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gcmVzcG9uc2UuZGF0YS5jcmVkZW50aWFscztcbiAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWxzLnJhdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIGdpdmVuIHByb3ZpZGVyIGNvbmZpZ3VyYXRpb24ga2V5IGFuZCBjb25uZWN0aW9uIElEXG4gICAgICogQHBhcmFtIHByb3ZpZGVyQ29uZmlnS2V5IC0gVGhlIGtleSBpZGVudGlmeWluZyB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbiBvbiBOYW5nb1xuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uSWQgLSBUaGUgSUQgb2YgdGhlIGNvbm5lY3Rpb24gZm9yIHdoaWNoIHRvIHJldHJpZXZlIG1ldGFkYXRhXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmV0cmlldmVkIG1ldGFkYXRhXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TWV0YWRhdGEocHJvdmlkZXJDb25maWdLZXksIGNvbm5lY3Rpb25JZCkge1xuICAgICAgICBpZiAoIXByb3ZpZGVyQ29uZmlnS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVyIENvbmZpZyBLZXkgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbm5lY3Rpb25JZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0aW9uIElkIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldENvbm5lY3Rpb25EZXRhaWxzKHByb3ZpZGVyQ29uZmlnS2V5LCBjb25uZWN0aW9uSWQsIGZhbHNlLCBmYWxzZSwge1xuICAgICAgICAgICAgJ05hbmdvLUlzLVN5bmMnOiB0cnVlLFxuICAgICAgICAgICAgJ05hbmdvLUlzLURyeS1SdW4nOiB0aGlzLmRyeVJ1blxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubWV0YWRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgY3VzdG9tIG1ldGFkYXRhIGZvciBhIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJDb25maWdLZXkgLSBUaGUga2V5IGlkZW50aWZ5aW5nIHRoZSBwcm92aWRlciBjb25maWd1cmF0aW9uIG9uIE5hbmdvXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCAtIFRoZSBJRChzKSBvZiB0aGUgY29ubmVjdGlvbihzKSBmb3Igd2hpY2ggdG8gc2V0IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIG1ldGFkYXRhIC0gVGhlIGN1c3RvbSBtZXRhZGF0YSB0byBzZXRcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBBeGlvcyByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBzZXRNZXRhZGF0YShwcm92aWRlckNvbmZpZ0tleSwgY29ubmVjdGlvbklkLCBtZXRhZGF0YSkge1xuICAgICAgICBpZiAoIXByb3ZpZGVyQ29uZmlnS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVyIENvbmZpZyBLZXkgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbm5lY3Rpb25JZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0aW9uIElkIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVXJsfS9jb25uZWN0aW9uL21ldGFkYXRhYDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5wb3N0KHVybCwgeyBtZXRhZGF0YSwgY29ubmVjdGlvbl9pZDogY29ubmVjdGlvbklkLCBwcm92aWRlcl9jb25maWdfa2V5OiBwcm92aWRlckNvbmZpZ0tleSB9LCB7IGhlYWRlcnM6IHRoaXMuZW5yaWNoSGVhZGVycygpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFZGl0cyBjdXN0b20gbWV0YWRhdGEgZm9yIGEgY29ubmVjdGlvbiwgb25seSBvdmVycmlkaW5nIHNwZWNpZmllZCBwcm9wZXJ0aWVzLCBub3QgdGhlIGVudGlyZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBwcm92aWRlckNvbmZpZ0tleSAtIFRoZSBrZXkgaWRlbnRpZnlpbmcgdGhlIHByb3ZpZGVyIGNvbmZpZ3VyYXRpb24gb24gTmFuZ29cbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIC0gVGhlIElEKHMpIG9mIHRoZSBjb25uZWN0aW9uKHMpIGZvciB3aGljaCB0byB1cGRhdGUgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBUaGUgY3VzdG9tIG1ldGFkYXRhIHRvIHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEF4aW9zIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU1ldGFkYXRhKHByb3ZpZGVyQ29uZmlnS2V5LCBjb25uZWN0aW9uSWQsIG1ldGFkYXRhKSB7XG4gICAgICAgIGlmICghcHJvdmlkZXJDb25maWdLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXIgQ29uZmlnIEtleSBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29ubmVjdGlvbklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gSWQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJVcmx9L2Nvbm5lY3Rpb24vbWV0YWRhdGFgO1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwLnBhdGNoKHVybCwgeyBtZXRhZGF0YSwgY29ubmVjdGlvbl9pZDogY29ubmVjdGlvbklkLCBwcm92aWRlcl9jb25maWdfa2V5OiBwcm92aWRlckNvbmZpZ0tleSB9LCB7IGhlYWRlcnM6IHRoaXMuZW5yaWNoSGVhZGVycygpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgc3BlY2lmaWMgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSBwcm92aWRlckNvbmZpZ0tleSAtIFRoZSBrZXkgaWRlbnRpZnlpbmcgdGhlIHByb3ZpZGVyIGNvbmZpZ3VyYXRpb24gb24gTmFuZ29cbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIC0gVGhlIElEIG9mIHRoZSBjb25uZWN0aW9uIHRvIGJlIGRlbGV0ZWRcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBBeGlvcyByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVDb25uZWN0aW9uKHByb3ZpZGVyQ29uZmlnS2V5LCBjb25uZWN0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJVcmx9L2Nvbm5lY3Rpb24vJHtjb25uZWN0aW9uSWR9P3Byb3ZpZGVyX2NvbmZpZ19rZXk9JHtwcm92aWRlckNvbmZpZ0tleX1gO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwLmRlbGV0ZSh1cmwsIHsgaGVhZGVyczogdGhpcy5lbnJpY2hIZWFkZXJzKGhlYWRlcnMpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiA9PT09PT09XG4gICAgICogU0NSSVBUU1xuICAgICAqICAgICAgQ09ORklHXG4gICAgICogPT09PT09PVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgYWxsIGludGVncmF0aW9uIHNjcmlwdHNcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyBmb3IgYWxsIGludGVncmF0aW9uIHNjcmlwdHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRTY3JpcHRzQ29uZmlnKCkge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLnNlcnZlclVybH0vc2NyaXB0cy9jb25maWdgO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cC5nZXQodXJsLCB7IGhlYWRlcnM6IHRoaXMuZW5yaWNoSGVhZGVycyhoZWFkZXJzKSB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqID09PT09PT1cbiAgICAgKiBTWU5DU1xuICAgICAqICAgICAgR0VUIFJFQ09SRFNcbiAgICAgKiAgICAgIFRSSUdHRVJcbiAgICAgKiAgICAgIFNUQVJUXG4gICAgICogICAgICBQQVVTRVxuICAgICAqICAgICAgU1RBVFVTXG4gICAgICogICAgICBHRVQgRU5WSVJPTk1FTlQgVkFSSUFCTEVTXG4gICAgICogPT09PT09PVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN5bmNlZCBkYXRhLCBvcmRlcmVkIGJ5IG1vZGlmaWNhdGlvbiBkYXRlIGFzY2VuZGluZ1xuICAgICAqIElmIHNvbWUgcmVjb3JkcyBhcmUgdXBkYXRlZCB3aGlsZSB5b3UgcGFnaW5hdGUgdGhyb3VnaCB0aGlzIGVuZHBvaW50LCB5b3UgbWlnaHQgc2VlIHRoZXNlIHJlY29yZHMgbXVsdGlwbGUgdGltZXNcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGxpc3RpbmcgcmVjb3Jkc1xuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgcmVjb3JkcyBhbmQgYSBjdXJzb3IgZm9yIHBhZ2luYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0UmVjb3Jkcyhjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uSWQsIHByb3ZpZGVyQ29uZmlnS2V5LCBtb2RlbCwgZGVsdGEsIG1vZGlmaWVkQWZ0ZXIsIGxpbWl0LCBmaWx0ZXIsIGN1cnNvciB9ID0gY29uZmlnO1xuICAgICAgICB2YWxpZGF0ZVN5bmNSZWNvcmRDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVXJsfS9yZWNvcmRzLz9tb2RlbD0ke21vZGVsfSR7ZGVsdGEgfHwgbW9kaWZpZWRBZnRlciA/IGAmbW9kaWZpZWRfYWZ0ZXI9JHttb2RpZmllZEFmdGVyIHx8IGRlbHRhfWAgOiAnJ30ke2xpbWl0ID8gYCZsaW1pdD0ke2xpbWl0fWAgOiAnJ30ke2ZpbHRlciA/IGAmZmlsdGVyPSR7ZmlsdGVyfWAgOiAnJ30ke2N1cnNvciA/IGAmY3Vyc29yPSR7Y3Vyc29yfWAgOiAnJ31gO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0Nvbm5lY3Rpb24tSWQnOiBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAnUHJvdmlkZXItQ29uZmlnLUtleSc6IHByb3ZpZGVyQ29uZmlnS2V5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmVucmljaEhlYWRlcnMoaGVhZGVycylcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHAuZ2V0KHVybCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhbiBhZGRpdGlvbmFsLCBvbmUtb2ZmIGV4ZWN1dGlvbiBvZiBzcGVjaWZpZWQgc3luYyhzKSBmb3IgYSBnaXZlbiBjb25uZWN0aW9uIG9yIGFsbCBhcHBsaWNhYmxlIGNvbm5lY3Rpb25zIGlmIG5vIGNvbm5lY3Rpb24gaXMgc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHByb3ZpZGVyQ29uZmlnS2V5IC0gVGhlIGtleSBpZGVudGlmeWluZyB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbiBvbiBOYW5nb1xuICAgICAqIEBwYXJhbSBzeW5jcyAtIEFuIG9wdGlvbmFsIGFycmF5IG9mIHN5bmMgbmFtZXMgdG8gdHJpZ2dlci4gSWYgZW1wdHksIGFsbCBhcHBsaWNhYmxlIHN5bmNzIHdpbGwgYmUgdHJpZ2dlcmVkXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCAtIEFuIG9wdGlvbmFsIElEIG9mIHRoZSBjb25uZWN0aW9uIGZvciB3aGljaCB0byB0cmlnZ2VyIHRoZSBzeW5jcy4gSWYgbm90IHByb3ZpZGVkLCBzeW5jcyB3aWxsIGJlIHRyaWdnZXJlZCBmb3IgYWxsIGFwcGxpY2FibGUgY29ubmVjdGlvbnNcbiAgICAgKiBAcGFyYW0gZnVsbFJlc3luYyAtIEFuIG9wdGlvbmFsIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHBlcmZvcm0gYSBmdWxsIHJlc3luY2hyb25pemF0aW9uLiBEZWZhdWx0IGlzIGZhbHNlXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc3luYyB0cmlnZ2VyIHJlcXVlc3QgaXMgc2VudFxuICAgICAqL1xuICAgIGFzeW5jIHRyaWdnZXJTeW5jKHByb3ZpZGVyQ29uZmlnS2V5LCBzeW5jcywgY29ubmVjdGlvbklkLCBmdWxsUmVzeW5jKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVXJsfS9zeW5jL3RyaWdnZXJgO1xuICAgICAgICBpZiAodHlwZW9mIHN5bmNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTeW5jcyBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuIElmIGl0IGlzIGEgc2luZ2xlIHN5bmMsIHBsZWFzZSB3cmFwIGl0IGluIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBzeW5jczogc3luY3MgfHwgW10sXG4gICAgICAgICAgICBwcm92aWRlcl9jb25maWdfa2V5OiBwcm92aWRlckNvbmZpZ0tleSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25faWQ6IGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIGZ1bGxfcmVzeW5jOiBmdWxsUmVzeW5jXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAucG9zdCh1cmwsIGJvZHksIHsgaGVhZGVyczogdGhpcy5lbnJpY2hIZWFkZXJzKCkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgc2NoZWR1bGUgb2Ygc3BlY2lmaWVkIHN5bmMocykgZm9yIGEgZ2l2ZW4gY29ubmVjdGlvbiBvciBhbGwgYXBwbGljYWJsZSBjb25uZWN0aW9ucyBpZiBubyBjb25uZWN0aW9uIGlzIHNwZWNpZmllZC4gVXBvbiBzdGFydGluZyB0aGUgc2NoZWR1bGUsIHRoZSBzeW5jIHdpbGwgZXhlY3V0ZSBpbW1lZGlhdGVseSBhbmQgdGhlbiBjb250aW51ZSB0byBydW4gYXQgdGhlIHNwZWNpZmllZCBmcmVxdWVuY3kuIElmIHRoZSBzY2hlZHVsZSB3YXMgYWxyZWFkeSBzdGFydGVkLCB0aGlzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAgICogQHBhcmFtIHByb3ZpZGVyQ29uZmlnS2V5IC0gVGhlIGtleSBpZGVudGlmeWluZyB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbiBvbiBOYW5nb1xuICAgICAqIEBwYXJhbSBzeW5jcyAtIEFuIG9wdGlvbmFsIGFycmF5IG9mIHN5bmMgbmFtZXMgdG8gc3RhcnQuIElmIGVtcHR5LCBhbGwgYXBwbGljYWJsZSBzeW5jcyB3aWxsIGJlIHN0YXJ0ZWRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIC0gQW4gb3B0aW9uYWwgSUQgb2YgdGhlIGNvbm5lY3Rpb24gZm9yIHdoaWNoIHRvIHN0YXJ0IHRoZSBzeW5jcy4gSWYgbm90IHByb3ZpZGVkLCBzeW5jcyB3aWxsIGJlIHN0YXJ0ZWQgZm9yIGFsbCBhcHBsaWNhYmxlIGNvbm5lY3Rpb25zXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc3luYyBzdGFydCByZXF1ZXN0IGlzIHNlbnRcbiAgICAgKi9cbiAgICBhc3luYyBzdGFydFN5bmMocHJvdmlkZXJDb25maWdLZXksIHN5bmNzLCBjb25uZWN0aW9uSWQpIHtcbiAgICAgICAgaWYgKCFwcm92aWRlckNvbmZpZ0tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlciBDb25maWcgS2V5IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzeW5jcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTeW5jIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzeW5jcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3luY3MgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLiBJZiBpdCBpcyBhIHNpbmdsZSBzeW5jLCBwbGVhc2Ugd3JhcCBpdCBpbiBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgc3luY3M6IHN5bmNzIHx8IFtdLFxuICAgICAgICAgICAgcHJvdmlkZXJfY29uZmlnX2tleTogcHJvdmlkZXJDb25maWdLZXksXG4gICAgICAgICAgICBjb25uZWN0aW9uX2lkOiBjb25uZWN0aW9uSWRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJVcmx9L3N5bmMvc3RhcnRgO1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwLnBvc3QodXJsLCBib2R5LCB7IGhlYWRlcnM6IHRoaXMuZW5yaWNoSGVhZGVycygpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHNjaGVkdWxlIG9mIHNwZWNpZmllZCBzeW5jKHMpIGZvciBhIGdpdmVuIGNvbm5lY3Rpb24gb3IgYWxsIGFwcGxpY2FibGUgY29ubmVjdGlvbnNcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJDb25maWdLZXkgLVRoZSBrZXkgaWRlbnRpZnlpbmcgdGhlIHByb3ZpZGVyIGNvbmZpZ3VyYXRpb24gb24gTmFuZ29cbiAgICAgKiBAcGFyYW0gc3luY3MgLSBBbiBvcHRpb25hbCBhcnJheSBvZiBzeW5jIG5hbWVzIHRvIHBhdXNlLiBJZiBlbXB0eSwgYWxsIGFwcGxpY2FibGUgc3luY3Mgd2lsbCBiZSBwYXVzZWRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIC0gQW4gb3B0aW9uYWwgSUQgb2YgdGhlIGNvbm5lY3Rpb24gZm9yIHdoaWNoIHRvIHBhdXNlIHRoZSBzeW5jcy4gSWYgbm90IHByb3ZpZGVkLCBzeW5jcyB3aWxsIGJlIHBhdXNlZCBmb3IgYWxsIGFwcGxpY2FibGUgY29ubmVjdGlvbnNcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBzeW5jIHBhdXNlIHJlcXVlc3QgaXMgc2VudFxuICAgICAqL1xuICAgIGFzeW5jIHBhdXNlU3luYyhwcm92aWRlckNvbmZpZ0tleSwgc3luY3MsIGNvbm5lY3Rpb25JZCkge1xuICAgICAgICBpZiAoIXByb3ZpZGVyQ29uZmlnS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVyIENvbmZpZyBLZXkgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN5bmNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bmMgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHN5bmNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTeW5jcyBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuIElmIGl0IGlzIGEgc2luZ2xlIHN5bmMsIHBsZWFzZSB3cmFwIGl0IGluIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVXJsfS9zeW5jL3BhdXNlYDtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHN5bmNzOiBzeW5jcyB8fCBbXSxcbiAgICAgICAgICAgIHByb3ZpZGVyX2NvbmZpZ19rZXk6IHByb3ZpZGVyQ29uZmlnS2V5LFxuICAgICAgICAgICAgY29ubmVjdGlvbl9pZDogY29ubmVjdGlvbklkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAucG9zdCh1cmwsIGJvZHksIHsgaGVhZGVyczogdGhpcy5lbnJpY2hIZWFkZXJzKCkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhdHVzIG9mIHNwZWNpZmllZCBzeW5jKHMpIGZvciBhIGdpdmVuIGNvbm5lY3Rpb24gb3IgYWxsIGFwcGxpY2FibGUgY29ubmVjdGlvbnNcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJDb25maWdLZXkgLSBUaGUga2V5IGlkZW50aWZ5aW5nIHRoZSBwcm92aWRlciBjb25maWd1cmF0aW9uIG9uIE5hbmdvXG4gICAgICogQHBhcmFtIHN5bmNzIC0gQW4gYXJyYXkgb2Ygc3luYyBuYW1lcyB0byBnZXQgc3RhdHVzIGZvciwgb3IgJyonIHRvIGdldCBzdGF0dXMgZm9yIGFsbCBzeW5jc1xuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uSWQgLSBBbiBvcHRpb25hbCBJRCBvZiB0aGUgY29ubmVjdGlvbiBmb3Igd2hpY2ggdG8gZ2V0IHN5bmMgc3RhdHVzLiBJZiBub3QgcHJvdmlkZWQsIHN0YXR1cyBmb3IgYWxsIGFwcGxpY2FibGUgY29ubmVjdGlvbnMgd2lsbCBiZSByZXRyaWV2ZWRcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBzdGF0dXMgb2YgdGhlIHNwZWNpZmllZCBzeW5jKHMpXG4gICAgICovXG4gICAgYXN5bmMgc3luY1N0YXR1cyhwcm92aWRlckNvbmZpZ0tleSwgc3luY3MsIGNvbm5lY3Rpb25JZCkge1xuICAgICAgICBpZiAoIXByb3ZpZGVyQ29uZmlnS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVyIENvbmZpZyBLZXkgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN5bmNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bmMgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHN5bmNzID09PSAnc3RyaW5nJyAmJiBzeW5jcyAhPT0gJyonKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bmNzIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy4gSWYgaXQgaXMgYSBzaW5nbGUgc3luYywgcGxlYXNlIHdyYXAgaXQgaW4gYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJVcmx9L3N5bmMvc3RhdHVzYDtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgc3luY3M6IHN5bmNzID09PSAnKicgPyAnKicgOiBzeW5jcy5qb2luKCcsJyksXG4gICAgICAgICAgICBwcm92aWRlcl9jb25maWdfa2V5OiBwcm92aWRlckNvbmZpZ0tleSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25faWQ6IGNvbm5lY3Rpb25JZFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cC5nZXQodXJsLCB7IGhlYWRlcnM6IHRoaXMuZW5yaWNoSGVhZGVycygpLCBwYXJhbXMgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBhIHN5bmPigJlzIGRlZmF1bHQgZnJlcXVlbmN5IGZvciBhIHNwZWNpZmljIGNvbm5lY3Rpb24sIG9yIHJldmVydCB0byB0aGUgZGVmYXVsdCBmcmVxdWVuY3lcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJDb25maWdLZXkgLSBUaGUga2V5IGlkZW50aWZ5aW5nIHRoZSBwcm92aWRlciBjb25maWd1cmF0aW9uIG9uIE5hbmdvXG4gICAgICogQHBhcmFtIHN5bmMgLSBUaGUgbmFtZSBvZiB0aGUgc3luYyB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIC0gVGhlIElEIG9mIHRoZSBjb25uZWN0aW9uIGZvciB3aGljaCB0byB1cGRhdGUgdGhlIHN5bmMgZnJlcXVlbmN5XG4gICAgICogQHBhcmFtIGZyZXF1ZW5jeSAtIFRoZSBuZXcgZnJlcXVlbmN5IHRvIHNldCBmb3IgdGhlIHN5bmMsIG9yIG51bGwgdG8gcmV2ZXJ0IHRvIHRoZSBkZWZhdWx0IGZyZXF1ZW5jeVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIGRhdGEgYWZ0ZXIgdXBkYXRpbmcgdGhlIHN5bmMgZnJlcXVlbmN5XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU3luY0Nvbm5lY3Rpb25GcmVxdWVuY3kocHJvdmlkZXJDb25maWdLZXksIHN5bmMsIGNvbm5lY3Rpb25JZCwgZnJlcXVlbmN5KSB7XG4gICAgICAgIGlmICghcHJvdmlkZXJDb25maWdLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXIgQ29uZmlnIEtleSBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc3luYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3luYyBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29ubmVjdGlvbklkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0aW9uSWQgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeSAhPT0gJ3N0cmluZycgJiYgZnJlcXVlbmN5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyZXF1ZW5jeSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJVcmx9L3N5bmMvdXBkYXRlLWNvbm5lY3Rpb24tZnJlcXVlbmN5YDtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgc3luYyxcbiAgICAgICAgICAgIHByb3ZpZGVyX2NvbmZpZ19rZXk6IHByb3ZpZGVyQ29uZmlnS2V5LFxuICAgICAgICAgICAgY29ubmVjdGlvbl9pZDogY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgZnJlcXVlbmN5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwLnB1dCh1cmwsIHsgaGVhZGVyczogdGhpcy5lbnJpY2hIZWFkZXJzKCksIHBhcmFtcyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXMgYWRkZWQgaW4gdGhlIE5hbmdvIGRhc2hib2FyZFxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVXJsfS9lbnZpcm9ubWVudC12YXJpYWJsZXNgO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cC5nZXQodXJsLCB7IGhlYWRlcnM6IHRoaXMuZW5yaWNoSGVhZGVycyhoZWFkZXJzKSB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqID09PT09PT1cbiAgICAgKiBBQ1RJT05TXG4gICAgICogICAgICBUUklHR0VSXG4gICAgICogPT09PT09PVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFuIGFjdGlvbiBmb3IgYSBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIHByb3ZpZGVyQ29uZmlnS2V5IC0gVGhlIGtleSBpZGVudGlmeWluZyB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbiBvbiBOYW5nb1xuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uSWQgLSBUaGUgSUQgb2YgdGhlIGNvbm5lY3Rpb24gZm9yIHdoaWNoIHRoZSBhY3Rpb24gc2hvdWxkIGJlIHRyaWdnZXJlZFxuICAgICAqIEBwYXJhbSBhY3Rpb25OYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGFjdGlvbiB0byB0cmlnZ2VyXG4gICAgICogQHBhcmFtIGlucHV0IC0gQW4gb3B0aW9uYWwgaW5wdXQgZGF0YSBmb3IgdGhlIGFjdGlvblxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc3BvbnNlIGRhdGEgZnJvbSB0aGUgdHJpZ2dlcmVkIGFjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIHRyaWdnZXJBY3Rpb24ocHJvdmlkZXJDb25maWdLZXksIGNvbm5lY3Rpb25JZCwgYWN0aW9uTmFtZSwgaW5wdXQpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJVcmx9L2FjdGlvbi90cmlnZ2VyYDtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb25uZWN0aW9uLUlkJzogY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgJ1Byb3ZpZGVyLUNvbmZpZy1LZXknOiBwcm92aWRlckNvbmZpZ0tleVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgYWN0aW9uX25hbWU6IGFjdGlvbk5hbWUsXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cC5wb3N0KHVybCwgYm9keSwgeyBoZWFkZXJzOiB0aGlzLmVucmljaEhlYWRlcnMoaGVhZGVycykgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiA9PT09PT09XG4gICAgICogUFJPWFlcbiAgICAgKiAgICAgIEdFVFxuICAgICAqICAgICAgUE9TVFxuICAgICAqICAgICAgUFVUXG4gICAgICogICAgICBQQVRDSFxuICAgICAqICAgICAgREVMRVRFXG4gICAgICogPT09PT09PVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcHJveGllZCBIVFRQIHJlcXVlc3QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgcHJveHkgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIGZyb20gdGhlIHByb3hpZWQgcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIHByb3h5KGNvbmZpZykge1xuICAgICAgICBpZiAoIWNvbmZpZy5jb25uZWN0aW9uSWQgJiYgdGhpcy5jb25uZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jb25uZWN0aW9uSWQgPSB0aGlzLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZy5wcm92aWRlckNvbmZpZ0tleSAmJiB0aGlzLnByb3ZpZGVyQ29uZmlnS2V5KSB7XG4gICAgICAgICAgICBjb25maWcucHJvdmlkZXJDb25maWdLZXkgPSB0aGlzLnByb3ZpZGVyQ29uZmlnS2V5O1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlUHJveHlDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHsgcHJvdmlkZXJDb25maWdLZXksIGNvbm5lY3Rpb25JZCwgbWV0aG9kLCByZXRyaWVzLCBoZWFkZXJzOiBjdXN0b21IZWFkZXJzLCBiYXNlVXJsT3ZlcnJpZGUsIGRlY29tcHJlc3MsIHJldHJ5T24gfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJVcmx9L3Byb3h5JHtjb25maWcuZW5kcG9pbnRbMF0gPT09ICcvJyA/ICcnIDogJy8nfSR7Y29uZmlnLmVuZHBvaW50fWA7XG4gICAgICAgIGNvbnN0IGN1c3RvbVByZWZpeGVkSGVhZGVycyA9IGN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBPYmplY3Qua2V5cyhjdXN0b21IZWFkZXJzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2BOYW5nby1Qcm94eS0ke2tleX1gXSA9IGN1c3RvbUhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pXG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0Nvbm5lY3Rpb24tSWQnOiBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAnUHJvdmlkZXItQ29uZmlnLUtleSc6IHByb3ZpZGVyQ29uZmlnS2V5LFxuICAgICAgICAgICAgJ0Jhc2UtVXJsLU92ZXJyaWRlJzogYmFzZVVybE92ZXJyaWRlIHx8ICcnLFxuICAgICAgICAgICAgJ05hbmdvLUlzLVN5bmMnOiB0aGlzLmlzU3luYyxcbiAgICAgICAgICAgICdOYW5nby1Jcy1EcnktUnVuJzogdGhpcy5kcnlSdW4sXG4gICAgICAgICAgICAnTmFuZ28tQWN0aXZpdHktTG9nLUlkJzogdGhpcy5hY3Rpdml0eUxvZ0lkIHx8ICcnLFxuICAgICAgICAgICAgLi4uY3VzdG9tUHJlZml4ZWRIZWFkZXJzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdXN0b21IZWFkZXJzPy5bJ0NvbnRlbnQtVHlwZSddKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IGN1c3RvbUhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyaWVzKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydSZXRyaWVzJ10gPSByZXRyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNvbXByZXNzKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydEZWNvbXByZXNzJ10gPSBkZWNvbXByZXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyeU9uKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydSZXRyeS1PbiddID0gcmV0cnlPbi5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZW5yaWNoSGVhZGVycyhoZWFkZXJzKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29uZmlnLnBhcmFtcykge1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMgPSBjb25maWcucGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcucGFyYW1zU2VyaWFsaXplcikge1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXNTZXJpYWxpemVyID0gY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kPy50b1VwcGVyQ2FzZSgpID09PSAnUE9TVCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHAucG9zdCh1cmwsIGNvbmZpZy5kYXRhLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXRob2Q/LnRvVXBwZXJDYXNlKCkgPT09ICdQQVRDSCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHAucGF0Y2godXJsLCBjb25maWcuZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWV0aG9kPy50b1VwcGVyQ2FzZSgpID09PSAnUFVUJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5wdXQodXJsLCBjb25maWcuZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWV0aG9kPy50b1VwcGVyQ2FzZSgpID09PSAnREVMRVRFJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5kZWxldGUodXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBHRVQgcmVxdWVzdCB1c2luZyB0aGUgcHJveHkgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgR0VUIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBmcm9tIHRoZSBHRVQgcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIGdldChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHkoe1xuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBQT1NUIHJlcXVlc3QgdXNpbmcgdGhlIHByb3h5IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIFBPU1QgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIGZyb20gdGhlIFBPU1QgcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIHBvc3QoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5KHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIFBBVENIIHJlcXVlc3QgdXNpbmcgdGhlIHByb3h5IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIFBBVENIIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBmcm9tIHRoZSBQQVRDSCByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgcGF0Y2goY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5KHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBERUxFVEUgcmVxdWVzdCB1c2luZyB0aGUgcHJveHkgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgREVMRVRFIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBmcm9tIHRoZSBERUxFVEUgcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHkoe1xuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gLS0gV2ViaG9va3NcbiAgICAvKipcbiAgICAgKlxuICAgICAqIFZlcmlmeSBpbmNvbWluZyB3ZWJob29rcyBzaWduYXR1cmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduYXR1cmVJbkhlYWRlciAtIFRoZSB2YWx1ZSBpbiB0aGUgaGVhZGVyIFgtTmFuZ28tU2lnbmF0dXJlXG4gICAgICogQHBhcmFtIGpzb25QYXlsb2FkIC0gVGhlIEhUVFAgYm9keSBhcyBKU09OXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkXG4gICAgICovXG4gICAgdmVyaWZ5V2ViaG9va1NpZ25hdHVyZShzaWduYXR1cmVJbkhlYWRlciwganNvblBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIChjcnlwdG9cbiAgICAgICAgICAgIC5jcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAgICAgLnVwZGF0ZShgJHt0aGlzLnNlY3JldEtleX0ke0pTT04uc3RyaW5naWZ5KGpzb25QYXlsb2FkKX1gKVxuICAgICAgICAgICAgLmRpZ2VzdCgnaGV4JykgPT09IHNpZ25hdHVyZUluSGVhZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGRldGFpbHMgb2YgYSBzcGVjaWZpYyBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIHByb3ZpZGVyQ29uZmlnS2V5IC0gVGhlIGtleSBpZGVudGlmeWluZyB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbiBvbiBOYW5nb1xuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uSWQgLSBUaGUgSUQgb2YgdGhlIGNvbm5lY3Rpb24gZm9yIHdoaWNoIHRvIHJldHJpZXZlIGNvbm5lY3Rpb24gZGV0YWlsc1xuICAgICAqIEBwYXJhbSBmb3JjZVJlZnJlc2ggLSBBbiBvcHRpb25hbCBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0byBmb3JjZSBhIHJlZnJlc2ggb2YgdGhlIGFjY2VzcyB0b2tlbnMuIERlZmF1bHRzIHRvIGZhbHNlXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiAtIEFuIG9wdGlvbmFsIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHNlbmQgdGhlIHJlZnJlc2ggdG9rZW4gYXMgcGFydCBvZiB0aGUgcmVzcG9uc2UuIERlZmF1bHRzIHRvIGZhbHNlXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxIZWFkZXIgLSBPcHRpb25hbC4gQWRkaXRpb25hbCBoZWFkZXJzIHRvIGluY2x1ZGUgaW4gdGhlIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBjb250YWluaW5nIGNvbm5lY3Rpb24gZGV0YWlsc1xuICAgICAqL1xuICAgIGFzeW5jIGdldENvbm5lY3Rpb25EZXRhaWxzKHByb3ZpZGVyQ29uZmlnS2V5LCBjb25uZWN0aW9uSWQsIGZvcmNlUmVmcmVzaCA9IGZhbHNlLCByZWZyZXNoVG9rZW4gPSBmYWxzZSwgYWRkaXRpb25hbEhlYWRlciA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVXJsfS9jb25uZWN0aW9uLyR7Y29ubmVjdGlvbklkfWA7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ05hbmdvLUlzLVN5bmMnOiB0aGlzLmlzU3luYyxcbiAgICAgICAgICAgICdOYW5nby1Jcy1EcnktUnVuJzogdGhpcy5kcnlSdW5cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxIZWFkZXIpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgYWRkaXRpb25hbEhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgcHJvdmlkZXJfY29uZmlnX2tleTogcHJvdmlkZXJDb25maWdLZXksXG4gICAgICAgICAgICBmb3JjZV9yZWZyZXNoOiBmb3JjZVJlZnJlc2gsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5nZXQodXJsLCB7IHBhcmFtczogcGFyYW1zLCBoZWFkZXJzOiB0aGlzLmVucmljaEhlYWRlcnMoaGVhZGVycykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkZXRhaWxzIG9mIGFsbCBjb25uZWN0aW9ucyBmcm9tIHRoZSBzZXJ2ZXIgb3IgZGV0YWlscyBvZiBhIHNwZWNpZmljIGNvbm5lY3Rpb24gaWYgYSBjb25uZWN0aW9uIElEIGlzIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCAtIE9wdGlvbmFsLiBUaGlzIGlzIHRoZSB1bmlxdWUgY29ubmVjdGlvbiBpZGVudGlmaWVyIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBjb25uZWN0aW9uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UgY29udGFpbmluZyBjb25uZWN0aW9uIGRldGFpbHNcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q29ubmVjdGlvbkRldGFpbHMoY29ubmVjdGlvbklkKSB7XG4gICAgICAgIGxldCB1cmwgPSBgJHt0aGlzLnNlcnZlclVybH0vY29ubmVjdGlvbj9gO1xuICAgICAgICBpZiAoY29ubmVjdGlvbklkKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwuY29uY2F0KGBjb25uZWN0aW9uSWQ9JHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5nZXQodXJsLCB7IGhlYWRlcnM6IHRoaXMuZW5yaWNoSGVhZGVycyhoZWFkZXJzKSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5yaWNoZXMgdGhlIGhlYWRlcnMgd2l0aCB0aGUgQXV0aG9yaXphdGlvbiB0b2tlblxuICAgICAqIEBwYXJhbSBoZWFkZXJzIC0gT3B0aW9uYWwuIFRoZSBoZWFkZXJzIHRvIGVucmljaFxuICAgICAqIEByZXR1cm5zIFRoZSBlbnJpY2hlZCBoZWFkZXJzXG4gICAgICovXG4gICAgZW5yaWNoSGVhZGVycyhoZWFkZXJzID0ge30pIHtcbiAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgdGhpcy5zZWNyZXRLZXk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/types.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/types.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SyncConfigType: () => (/* binding */ SyncConfigType)\n/* harmony export */ });\nvar SyncConfigType;\n(function (SyncConfigType) {\n    SyncConfigType[\"SYNC\"] = \"sync\";\n    SyncConfigType[\"ACTION\"] = \"action\";\n})(SyncConfigType || (SyncConfigType = {}));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5hbmdvaHErbm9kZUAwLjQyLjEwL25vZGVfbW9kdWxlcy9AbmFuZ29ocS9ub2RlL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFyYmxpc20vbmV4dGpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuYW5nb2hxK25vZGVAMC40Mi4xMC9ub2RlX21vZHVsZXMvQG5hbmdvaHEvbm9kZS9kaXN0L3R5cGVzLmpzPzVmYmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBTeW5jQ29uZmlnVHlwZTtcbihmdW5jdGlvbiAoU3luY0NvbmZpZ1R5cGUpIHtcbiAgICBTeW5jQ29uZmlnVHlwZVtcIlNZTkNcIl0gPSBcInN5bmNcIjtcbiAgICBTeW5jQ29uZmlnVHlwZVtcIkFDVElPTlwiXSA9IFwiYWN0aW9uXCI7XG59KShTeW5jQ29uZmlnVHlwZSB8fCAoU3luY0NvbmZpZ1R5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/utils.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/utils.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUserAgent: () => (/* binding */ getUserAgent),\n/* harmony export */   validateProxyConfiguration: () => (/* binding */ validateProxyConfiguration),\n/* harmony export */   validateSyncRecordConfiguration: () => (/* binding */ validateSyncRecordConfiguration)\n/* harmony export */ });\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./version.js */ \"(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/version.js\");\n\n\n/**\n * Validates the configuration for a proxy call\n * @param config - Configuration object for the proxy call\n * @throws If required parameters are missing in the configuration\n */\nconst validateProxyConfiguration = (config) => {\n    const requiredParams = ['endpoint', 'providerConfigKey', 'connectionId'];\n    requiredParams.forEach((param) => {\n        if (typeof config[param] === 'undefined') {\n            throw new Error(`${param} is missing and is required to make a proxy call!`);\n        }\n    });\n};\n/**\n * Validates the configuration for fetching sync records\n * @param config - Configuration object for fetching sync records\n * @throws If required parameters are missing in the configuration\n */\nconst validateSyncRecordConfiguration = (config) => {\n    const requiredParams = ['model', 'providerConfigKey', 'connectionId'];\n    requiredParams.forEach((param) => {\n        if (typeof config[param] === 'undefined') {\n            throw new Error(`${param} is missing and is required to make a proxy call!`);\n        }\n    });\n};\nfunction getUserAgent(userAgent) {\n    const nodeVersion = process.versions.node;\n    const osName = os__WEBPACK_IMPORTED_MODULE_0__.platform().replace(' ', '_');\n    const osVersion = os__WEBPACK_IMPORTED_MODULE_0__.release().replace(' ', '_');\n    return `nango-node-client/${_version_js__WEBPACK_IMPORTED_MODULE_1__.NANGO_VERSION} (${osName}/${osVersion}; node.js/${nodeVersion})${userAgent ? `; ${userAgent}` : ''}`;\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5hbmdvaHErbm9kZUAwLjQyLjEwL25vZGVfbW9kdWxlcy9AbmFuZ29ocS9ub2RlL2Rpc3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBb0I7QUFDeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQSxtQkFBbUIsd0NBQVc7QUFDOUIsc0JBQXNCLHVDQUFVO0FBQ2hDLGdDQUFnQyxzREFBYSxFQUFFLEdBQUcsT0FBTyxHQUFHLFlBQVksVUFBVSxZQUFZLEdBQUcsZUFBZSxFQUFFLFVBQVUsT0FBTztBQUNuSTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hcmJsaXNtL25leHRqcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmFuZ29ocStub2RlQDAuNDIuMTAvbm9kZV9tb2R1bGVzL0BuYW5nb2hxL25vZGUvZGlzdC91dGlscy5qcz85NGViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgeyBOQU5HT19WRVJTSU9OIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbi8qKlxuICogVmFsaWRhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBhIHByb3h5IGNhbGxcbiAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHByb3h5IGNhbGxcbiAqIEB0aHJvd3MgSWYgcmVxdWlyZWQgcGFyYW1ldGVycyBhcmUgbWlzc2luZyBpbiB0aGUgY29uZmlndXJhdGlvblxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVQcm94eUNvbmZpZ3VyYXRpb24gPSAoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgcmVxdWlyZWRQYXJhbXMgPSBbJ2VuZHBvaW50JywgJ3Byb3ZpZGVyQ29uZmlnS2V5JywgJ2Nvbm5lY3Rpb25JZCddO1xuICAgIHJlcXVpcmVkUGFyYW1zLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnW3BhcmFtXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtwYXJhbX0gaXMgbWlzc2luZyBhbmQgaXMgcmVxdWlyZWQgdG8gbWFrZSBhIHByb3h5IGNhbGwhYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgZmV0Y2hpbmcgc3luYyByZWNvcmRzXG4gKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGZldGNoaW5nIHN5bmMgcmVjb3Jkc1xuICogQHRocm93cyBJZiByZXF1aXJlZCBwYXJhbWV0ZXJzIGFyZSBtaXNzaW5nIGluIHRoZSBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVN5bmNSZWNvcmRDb25maWd1cmF0aW9uID0gKGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IHJlcXVpcmVkUGFyYW1zID0gWydtb2RlbCcsICdwcm92aWRlckNvbmZpZ0tleScsICdjb25uZWN0aW9uSWQnXTtcbiAgICByZXF1aXJlZFBhcmFtcy5mb3JFYWNoKChwYXJhbSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZ1twYXJhbV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cGFyYW19IGlzIG1pc3NpbmcgYW5kIGlzIHJlcXVpcmVkIHRvIG1ha2UgYSBwcm94eSBjYWxsIWApO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBZ2VudCh1c2VyQWdlbnQpIHtcbiAgICBjb25zdCBub2RlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgICBjb25zdCBvc05hbWUgPSBvcy5wbGF0Zm9ybSgpLnJlcGxhY2UoJyAnLCAnXycpO1xuICAgIGNvbnN0IG9zVmVyc2lvbiA9IG9zLnJlbGVhc2UoKS5yZXBsYWNlKCcgJywgJ18nKTtcbiAgICByZXR1cm4gYG5hbmdvLW5vZGUtY2xpZW50LyR7TkFOR09fVkVSU0lPTn0gKCR7b3NOYW1lfS8ke29zVmVyc2lvbn07IG5vZGUuanMvJHtub2RlVmVyc2lvbn0pJHt1c2VyQWdlbnQgPyBgOyAke3VzZXJBZ2VudH1gIDogJyd9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/version.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/version.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NANGO_VERSION: () => (/* binding */ NANGO_VERSION)\n/* harmony export */ });\nconst NANGO_VERSION = '0.42.10';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5hbmdvaHErbm9kZUAwLjQyLjEwL25vZGVfbW9kdWxlcy9AbmFuZ29ocS9ub2RlL2Rpc3QvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0anMvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5hbmdvaHErbm9kZUAwLjQyLjEwL25vZGVfbW9kdWxlcy9AbmFuZ29ocS9ub2RlL2Rpc3QvdmVyc2lvbi5qcz8wYTYzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBOQU5HT19WRVJTSU9OID0gJzAuNDIuMTAnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@nangohq+node@0.42.10/node_modules/@nangohq/node/dist/version.js\n");

/***/ })

};
;